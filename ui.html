<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-size: 13px;
        }

        html, body {
            min-height: auto;
            height: auto;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #2c2c2c;
            color: #fcfcfc;
            padding: 16px;
            font-size: 13px;
            line-height: 1.4;
            overflow: hidden;
            display: flex; 
            flex-direction: column;
            transition: all 0.3s ease-in-out;
        }

        .main-content { 
            flex: 1; 
            transition: all 0.3s ease-in-out;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .plugin-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
        }

        .step-indicator {
            display: flex;
            align-items: center;
            gap: 26px;
            margin-bottom: 15px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #999;
        }

        .step.active {
            color: #ffffff;
        }

        .step-number {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #212121;
            color: #fcfcfc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            border: 1px solid #3d3d3d;
            /* font-weight: 600; */
        }

        .step.active .step-number {
            background: #fcfcfc;
            color: #212121;
        }

        .header-border{
            position: relative;
            left: 50%;
            right: 50%;
            margin-left: -50vw;
            margin-right: -50vw;
            width: 100vw;
            max-width: 100vw;
            border: 0.8px solid #444444;
            margin-bottom: 30px;
            height: 0px;
            padding: 0;
            flex: none;
            order: 3;
            align-self: stretch;
            flex-grow: 0;

        }

        .selected-layer {
            background: #3a3a3a;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
            text-align: center;
            font-size: 13px;
            color: #ccc;

        }

        .layer-name {
            font-weight: 600;
            color: #fcfcfc;
        }

        .input-section {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .input-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 260px;
            margin: 0 auto;
            gap: 10px;
        }

        .input-label {
            font-size: 13px;
            color: #fcfcfc;
            text-align: center;
        }

        .text-input {
            width: 100%;
            max-width: 260px;
            padding: 10px 12px;
            padding: 14px 12px;
            color: #fcfcfc;
            font-size: 13px;
            font-family: inherit;
            background: #262626;
            border: 1px solid #3D3D3D;
            border-radius: 6px;
            margin-bottom: 0;
        }

        .text-input:focus {
            outline: none;
            border-color: #0066ff;
        }

        .text-input::placeholder {
            color: #727272;
        }

        .animate-btn, .create-btn {
            width: 100%;
            background: #3B82F6;
            border: none;
            border-radius: 6px;
            max-width: 80px;
            padding: 8px 0;
            color: #fcfcfc;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 0;
            box-shadow: 0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -2px rgba(0, 0, 0, 0.1);
            margin-top: 10px;
            letter-spacing: 0.5;
        }

        .create-btn {
            max-width: 160px;
            align-items: center;
            margin-top: 15px;
            display: flex;
            justify-content: center; 
            gap: 6px;
        }

        .animate-btn:hover {
            background: #0052cc;
        }

        .animate-btn:disabled {
            color: #71717A;
            cursor: not-allowed;
            background: #353535;

        }

        .preview-section {
            display: none;
        }

        .preview-section.active {
            display: block;
        }

        .back-btn {
            background: none;
            border: none;
            color: #fcfcfc;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 16px;
            padding: 4px 0;
        }

        .preview-container {
            background: #212121;
            border: 1px solid #3F3F46;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            height: 80px;
            max-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .preview-text {
            font-size: 16px;
            font-weight: 400;
            color: #fcfcfc;
            text-align: center;
            max-width: 100%;
            word-wrap: break-word;
            line-height: 1.2;
        }
        
        .preview-text.scrolling {
            animation: scrollUp linear infinite;
        }
        
        @keyframes scrollUp {
            0% {
                transform: translateY(100%);
            }
            100% {
                transform: translateY(-100%);
            }
        }

        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 26px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 13px;
            color: #fcfcfc;
            font-weight: 400;
        }

        .select-input {
            background: #212121;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 6px 20px 6px 8px;
            color: #fcfcfc;
            font-size: 13px;
            font-family: inherit;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23fcfcfc' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 4px center;
            background-repeat: no-repeat;
            background-size: 16px 16px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }
        .select-input--small {
            width: 85px;
        }

        .select-input:focus {
            outline: none;
            border-color: #0066ff;
        }

        .text-input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #1a1a1a;
            color: #999;
        }

        .input-wrapper {
            position: relative;
        }

        .input-tooltip {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1000;
            pointer-events: none;
        }

        .input-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #333;
        }

        .input-tooltip.show.hover-active {
            opacity: 1;
            visibility: visible;
        }

        .custom-select-wrapper {
            position: relative;
        }

        .select-input option:disabled {
            color: #666 !important;
            background-color: #2a2a2a !important;
        }

        .select-tooltip {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1000;
            pointer-events: none;
        }

        .select-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #333;
        }

        .custom-select-wrapper:hover .select-tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .input-label.selected {
            color: #3B82F6 !important;
            font-weight: 500;
        }

        .character-counter {
            font-size: 10px;
            color: #9CA3AF;
            text-align: right;
            margin-top: 8px;
            margin-right: 2px;
            transition: color 0.2s ease;
        }

        .character-counter.warning {
            color: #F59E0B;
        }

        .character-counter.error {
            color: #EF4444;
        }

        .character-warning {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #EF4444;
            border-radius: 6px;
            padding: 8px 12px;
            margin-top: 8px;
            font-size: 10px;
            color: #EF4444;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .selected-layer {
            background: #2a4d3a;
            border: 1px solid #3B82F6;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
            text-align: center;
            font-size: 13px;
            color: #ccc;
        }

        .selected-layer.active {
            background: #1e3a2e;
            border-color: #22c55e;
        }

        .layer-name {
            font-weight: 600;
            color: #22c55e;
        }

        .radio-group {
            display: flex;
            gap: 26px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #fcfcfc;
            cursor: pointer;
            

        }

        .radio-option input[type="radio"] {
            width: 12px;
            height: 12px;
            appearance: none; 
            -webkit-appearance: none;
            border-radius: 50%; 
            background: #212121; 
            border: 1px solid #444444; 
            position: relative; 
            cursor: pointer;
        }

        .radio-option input[type="radio"]:checked { 
            background: #212121; 
            border: 1px solid #444444; 
        }

        .radio-option input[type="radio"]:checked::after { 
            content: ''; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 6px; 
            height: 6px; 
            border-radius: 50%; 
            background: #fcfcfc;
        }

        .duration-container {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .duration-input-wrapper{
            position: relative; 
            display: flex; 
            align-items: center;
        }

        .duration-input-wrapper svg{
            position: absolute; 
            left: 4px; 
            z-index: 1; 
            pointer-events: none;
        }

        .duration-input {
            background: #212121;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 4px 10px 4px 20px;
            color: #fcfcfc;
            font-size: 13px;
            font-family: inherit;
            width: 90px;
            -moz-appearance: textfield;
        }

        .duration-input--small{
            width: 70px;
        }

        .duration-input::-webkit-outer-spin-button, .duration-input::-webkit-inner-spin-button { 
            -webkit-appearance: none; margin: 0; 
        }

        .duration-arrows { 
            position: absolute; 
            right: 10px; 
            top: 50%; 
            transform: translateY(-50%); 
            display: flex; 
            flex-direction: column; 
            cursor: pointer; 
            pointer-events: auto;
            z-index: 10;
            width: 12px;
            height: 12px;
        }

        .duration-input:focus {
            outline: none;
            border-color: #727272;
            background-color: #212121;
        }



        .create-btn:hover {
            background: #0052cc;
        }

        .create-btn:disabled {
            background: #71717A;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .create-btn.loading {
            background: #71717A;
            cursor: not-allowed;
            pointer-events: none;
        }

        .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid #ffffff40;
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .export-json-btn {
            max-width: 160px;
            align-items: center;
            display: flex;
            justify-content: center; 
            gap: 6px;
            width: 100%;
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 8px 0;
            color: #9CA3AF;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-json-btn:hover:not(:disabled) {
            background: rgba(59, 130, 246, 0.1);
            color: #3B82F6;
        }

        .export-json-btn:disabled {
            color: #71717A;
            background: transparent;
            cursor: not-allowed;
            position: relative;
        }

        .export-json-btn:disabled:hover::after {
            content: "Coming Soon";
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            padding: 6px 10px;
            background: #18181B;
            color: #ffffff;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        .export-json-btn:disabled:hover::before {
            content: "";
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: #18181B;
            z-index: 1000;
            pointer-events: none;
        }

        .color-picker-container {
            position: absolute;
            top: -35px;
            right: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
        }

        .color-picker-button {
            width: 16px;
            height: 16px;
            border: 1px solid #3D3D3D;
            border-radius: 3px;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #9CA3AF;
            transition: all 0.2s;
        }

        .color-picker-button:hover {
            border-color: #3B82F6;
            color: #3B82F6;
        }

        .color-hex-display {
            font-size: 12px;
            color: #9CA3AF;
            /* font-family: 'Courier New', monospace; */
            min-width: 60px;
            user-select: all;
        }

        .play-pause-btn {
            position: absolute !important;
            top: 0px;
            right: 0px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            z-index: 100 !important;
            transition: all 0.2s ease;
            pointer-events: auto !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Default state (paused) - show play icons */
        .play-pause-btn[data-state="paused"] .play-icon {
            display: block;
        }

        .play-pause-btn[data-state="paused"] .pause-icon {
            display: none;
        }

        /* Playing state - show pause icons */
        .play-pause-btn[data-state="playing"] .play-icon {
            display: none;
        }

        .play-pause-btn[data-state="playing"] .pause-icon.small-icon {
            display: block;
        }
        .play-pause-btn[data-state="playing"] .pause-icon.hover-icon {
            display: none;
        }

        /* Hover states - hide small icons and show appropriate large icon */
        .play-pause-btn[data-state="paused"]:hover .small-icon {
            display: none;
        }

        .play-pause-btn[data-state="paused"]:hover .play-icon.hover-icon {
            display: block !important;
        }

        .play-pause-btn[data-state="paused"]:hover .pause-icon {
            display: none;
        }

        .play-pause-btn[data-state="playing"]:hover .small-icon {
            display: none;
        }

        .play-pause-btn[data-state="playing"]:hover .pause-icon.hover-icon {
            display: block !important;
        }

        .play-pause-btn[data-state="playing"]:hover .play-icon {
            display: none;
        }

        .typing-cursor {
            animation: blink 1s infinite;
            color: inherit;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .footer {
            margin-top: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #9CA3AF;
        }

        .footer a {
            color: #3B82F6;
            text-decoration: none;
        }

        .beta-version {
            position: relative;
            cursor: pointer;
        }

        .beta-text {
            transition: color 0.2s ease;
        }

        .beta-version:hover .beta-text {
            color: #FFFFFF;
        }

        .credits-tooltip {
            position: absolute;
            bottom: 25px;
            left: 0;
            background: #333;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 11px;
            color: #9CA3AF;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transform: translateY(5px);
            transition: all 0.2s ease;
            z-index: 1000;
            line-height: 1.4;
        }

        .beta-version:hover .credits-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .credit-link {
            color: #3B82F6 !important;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .credit-link:hover {
            color: #60A5FA !important;
            text-decoration: underline;
        }

        /* Animation classes */
        .animate-typing {
            overflow: hidden;
            white-space: nowrap;
            border-right: 2px solid #fcfcfc;
            animation: typing 5s steps(40, end), blink-caret 0.75s step-end infinite;
        }
/* 
        .choose-section, .preview-section {
            transition: opacity 0.5s ease-in-out;
        }

        .choose-section.hiding, .preview-section.hiding {
            opacity: 0;
        } */

        @keyframes typing {
            from { width: 0; }
            to { width: 100%; }
        }

        @keyframes blink-caret {
            from, to { border-color: transparent; }
            50% { border-color: #fcfcfc; }
        }

        .animate-fade-in {
            animation: fadeIn 1s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .animate-fade-out {
            animation: fadeOut 1s ease-in-out;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .animate-slide-left {
            animation: slideLeft 1s ease-in-out;
        }

        @keyframes slideLeft {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .animate-slide-right {
            animation: slideRight 1s ease-in-out;
        }

        @keyframes slideRight {
            from { transform: translateX(-100%); }
            to { transform: translateX(0); }
        }

        .animate-slide-up {
            animation: slideUp 1s ease-in-out;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .animate-slide-down {
            animation: slideDown 1s ease-in-out;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }

        .animate-scale {
            animation: scale 1s ease-out;
        }

        @keyframes scale {
            from { 
                transform: scale(0);
                opacity: 0;
            }
            to { 
                transform: scale(1);
                opacity: 1;
            }
        }

        .animate-scale-grow {
            animation: scaleGrow 1s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes scaleGrow {
            0% { 
                transform: scale(0);
                opacity: 0;
            }
            60% {
                transform: scale(1.1);
                opacity: 1;
            }
            100% { 
                transform: scale(1);
                opacity: 1;
            }
        }

        .animate-scale-shrink {
            animation: scaleShrink 1s cubic-bezier(0.64, 0, 0.66, -0.56);
        }

        @keyframes scaleShrink {
            0% { 
                transform: scale(1);
                opacity: 1;
            }
            40% {
                transform: scale(0.9);
                opacity: 1;
            }
            100% { 
                transform: scale(0);
                opacity: 0;
            }
        }

        .animate-rotate {
            animation: rotate 1s ease-in-out;
        }

        .animate-rotate-backwards {
            animation: rotate-backwards 1s ease-in-out;
        }

        @keyframes rotate {
            from { transform: rotate(-180deg) scale(0); }
            to { transform: rotate(0deg) scale(1); }
        }

        @keyframes rotate-backwards {
            from { transform: rotate(180deg) scale(0); }
            to { transform: rotate(0deg) scale(1); }
        }

        .letter {
            display: inline-block;
        }

        .typing-cursor {
            display: inline-block;
            color: #fcfcfc;
            font-weight: normal;
        }

        /* Feedback Modal Styles */
        .feedback-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 44, 44, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 1000;
            display: none;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 20px;
        }

        .feedback-modal {
            background: transparent;
            border-radius: 12px 12px 0 0;
            padding: 24px;
            width: 100%;
            max-width: 450px;
            /* border: 1px solid #444; */
            /* box-shadow: 0 -4px 20px rgba(44, 0, 0, 0.3); */
            display: flex;
            flex-direction: column;
        }

        .feedback-title {
            color: #fcfcfc;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .feedback-input-container {
            position: relative;
            margin-bottom: 16px;
        }

        .feedback-textarea {
            width: 100%;
            min-height: 120px;
            background: #262626;
            border: 1px solid #3D3D3D;
            border-radius: 8px;
            padding: 12px 40px 35px 12px;
            color: #fcfcfc;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            line-height: 1.4;
        }

        .feedback-textarea:focus {
            outline: none;
            border-color: #3B82F6;
        }

        .feedback-textarea::placeholder {
            color: #727272;
        }

        .feedback-controls {
            position: absolute;
            bottom: 8px;
            left: 12px;
            right: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .image-upload-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        .image-upload-btn:hover {
            color: #fcfcfc;
        }

        .uploaded-file {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #3B82F6;
            background: rgba(59, 130, 246, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .remove-file-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 14px;
            padding: 0 2px;
        }

        .word-counter {
            font-size: 12px;
            color: #999;
        }

        .word-counter.error {
            color: #ff4444;
        }

        .feedback-submit-btn {
            width: 120px;
            background: #3B82F6;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            color: #fcfcfc;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            align-self: center;
            margin: 0 auto;
        }

        .feedback-submit-btn:hover {
            background: #2563eb;
        }

        .feedback-submit-btn:disabled {
            background: #444;
            color: #999;
            cursor: not-allowed;
        }

        .feedback-error {
            color: #ff4444;
            font-size: 12px;
            margin-top: 8px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="step-indicator">
            <div class="step active" id="step1">
                <div class="step-number">1</div>
                <span>Choose subject</span>
            </div>
            <div class="step" id="step2">
                <div class="step-number">2</div>
                <span>Preview animation</span>
            </div>
        </div>
        <div class="header-border"></div>
        <!-- Step 1: Choose Subject -->
        <div class="choose-section" id="choose-section">
            <div class="selected-layer" id="selected-layer" style="display: none;">
                <div><span class="layer-name" id="layer-name"></span> selected</div>
            </div>

            <div class="input-section">
                <div class="input-label" id="input-label">Select a text layer</div>
                <div class="input-label" style="margin: 15px 15px; color: #fcfcfc;">or</div>
                <div class="input-wrapper">
                    <div class="input-tooltip" id="input-tooltip">Deselect the text layer to enable typing</div>
                    <input type="text" class="text-input" id="text-input" placeholder="Enter a word or sentence">
                    <button class="animate-btn" id="animate-btn" disabled>Animate</button>
                </div>
                <div class="character-counter" id="character-counter">0/100</div>
                <div class="character-warning" id="character-warning" style="display: none;">
                    Text exceeds 100 character limit. Please shorten before animating.
                </div>
            </div>
        </div>

        <!-- Step 2: Preview Animation -->
        <div class="preview-section" id="preview-section">
            <button class="back-btn" id="back-btn">
                <div style="display: flex; flex-direction: row; align-items: center; gap: 5px;">
                    <svg width="16" height="16" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M6.25 8.29995L3.53333 5.58328C3.2125 5.26245 3.2125 4.73745 3.53333 4.41662L6.25 1.69995" stroke="white" stroke-width="0.625" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span style="margin-left: 2px;">Preview</span>
                </div>
            
            </button>

            <div style="position: relative;">
                <div class="preview-container" id="preview-container">
                    <div class="preview-text" id="preview-text">Sample Text</div>
                    <button class="play-pause-btn" id="play-pause-btn" data-state="paused">
                        <!-- Default play state (small) -->
                        <svg class="play-icon small-icon" width="32" height="26" viewBox="0 0 22 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <foreignObject x="-4" y="-4" width="30" height="26"><div xmlns="http://www.w3.org/1999/xhtml" style="backdrop-filter:blur(2px);clip-path:url(#bgblur_0_5243_457_clip_path);height:100%;width:100%"></div></foreignObject>
                            <g data-figma-bg-blur-radius="4">
                                <path d="M14 0.5C18.1421 0.5 21.5 3.85786 21.5 8V17.5H8C3.85786 17.5 0.5 14.1421 0.5 10V0.5H14Z" fill="#242424"/>
                                <!-- Left border -->
                                <path d="M0.5 0.5V10C0.5 14.1421 3.85786 17.5 8 17.5" stroke="#3F3F46" fill="none"/>
                                <!-- Bottom border -->
                                <path d="M8 17.5H21.5" stroke="#3F3F46" fill="none"/>
                                <path d="M13.2111 8.10553C13.9482 8.47405 13.9482 9.52586 13.2111 9.89438L10.4472 11.2763C9.78231 11.6088 9 11.1253 9 10.3819L9 7.61799C9 6.87461 9.78231 6.39111 10.4472 6.72356L13.2111 8.10553Z" fill="white"/>
                            </g>
                            <defs>
                                <clipPath id="bgblur_0_5243_457_clip_path" transform="translate(4 4)"><path d="M14 0.5C18.1421 0.5 21.5 3.85786 21.5 8V17.5H8C3.85786 17.5 0.5 14.1421 0.5 10V0.5H14Z"/></clipPath>
                            </defs>
                        </svg>
                        
                        <!-- Pause state (small) -->
                        <svg class="pause-icon small-icon" width="32" height="26" viewBox="0 0 22 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <foreignObject x="-4" y="-4" width="30" height="26"><div xmlns="http://www.w3.org/1999/xhtml" style="backdrop-filter:blur(2px);clip-path:url(#bgblur_0_4838_524_clip_path);height:100%;width:100%"></div></foreignObject>
                            <g data-figma-bg-blur-radius="4">
                                <path d="M14 0.5C18.1421 0.5 21.5 3.85786 21.5 8V17.5H8C3.85786 17.5 0.5 14.1421 0.5 10V0.5H14Z" fill="#242424"/>
                                <!-- Left border -->
                                <path d="M0.5 0.5V10C0.5 14.1421 3.85786 17.5 8 17.5" stroke="#3F3F46" fill="none"/>
                                <!-- Bottom border -->
                                <path d="M8 17.5H21.5" stroke="#3F3F46" fill="none"/>
                                <path d="M10.6625 10.7775V7.2225C10.6625 6.885 10.52 6.75 10.16 6.75H9.2525C8.8925 6.75 8.75 6.885 8.75 7.2225V10.7775C8.75 11.115 8.8925 11.25 9.2525 11.25H10.16C10.52 11.25 10.6625 11.115 10.6625 10.7775Z" fill="white"/>
                                <path d="M13.25 10.7775V7.2225C13.25 6.885 13.1075 6.75 12.7475 6.75H11.84C11.4825 6.75 11.3375 6.885 11.3375 7.2225V10.7775C11.3375 11.115 11.48 11.25 11.84 11.25H12.7475C13.1075 11.25 13.25 11.115 13.25 10.7775Z" fill="white"/>
                            </g>
                            <defs>
                                <clipPath id="bgblur_0_4838_524_clip_path" transform="translate(4 4)"><path d="M14 0.5C18.1421 0.5 21.5 3.85786 21.5 8V17.5H8C3.85786 17.5 0.5 14.1421 0.5 10V0.5H14Z"/></clipPath>
                            </defs>
                        </svg>
                        
                        <!-- Hover pause state (large) -->
                        <svg class="pause-icon hover-icon" width="65" height="30" viewBox="0 0 50 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <foreignObject x="-4" y="-4" width="58" height="30"><div xmlns="http://www.w3.org/1999/xhtml" style="backdrop-filter:blur(2px);clip-path:url(#bgblur_0_4817_1549_clip_path);height:100%;width:100%"></div></foreignObject>
                            <g data-figma-bg-blur-radius="4">
                                <path d="M42 0.5C46.1421 0.5 49.5 3.85786 49.5 8V21.5H8C3.85787 21.5 0.5 18.1421 0.5 14V0.5H42Z" fill="#242424"/>
                                <!-- Left border -->
                                <path d="M0.5 0.5V14C0.5 18.1421 3.85787 21.5 8 21.5" stroke="#3F3F46" fill="none"/>
                                <!-- Bottom border -->
                                <path d="M8 21.5H49.5" stroke="#3F3F46" fill="none"/>
                                <path d="M10.6625 12.7775V9.2225C10.6625 8.885 10.52 8.75 10.16 8.75H9.2525C8.8925 8.75 8.75 8.885 8.75 9.2225V12.7775C8.75 13.115 8.8925 13.25 9.2525 13.25H10.16C10.52 13.25 10.6625 13.115 10.6625 12.7775Z" fill="white"/>
                                <path d="M13.25 12.7775V9.2225C13.25 8.885 13.1075 8.75 12.7475 8.75H11.84C11.4825 8.75 11.3375 8.885 11.3375 9.2225V12.7775C11.3375 13.115 11.48 13.25 11.84 13.25H12.7475C13.1075 13.25 13.25 13.115 13.25 12.7775Z" fill="white"/>
                                <path d="M19.2642 14V8.18182H21.3381C21.7907 8.18182 22.1657 8.2642 22.4631 8.42898C22.7604 8.59375 22.983 8.81913 23.1307 9.10511C23.2784 9.3892 23.3523 9.70928 23.3523 10.0653C23.3523 10.4233 23.2775 10.7453 23.1278 11.0312C22.9801 11.3153 22.7566 11.5407 22.4574 11.7074C22.16 11.8722 21.786 11.9545 21.3352 11.9545H19.9091V11.2102H21.2557C21.5417 11.2102 21.7737 11.161 21.9517 11.0625C22.1297 10.9621 22.2604 10.8258 22.3438 10.6534C22.4271 10.4811 22.4688 10.285 22.4688 10.0653C22.4688 9.84564 22.4271 9.65057 22.3438 9.48011C22.2604 9.30966 22.1288 9.17614 21.9489 9.07955C21.7708 8.98295 21.536 8.93466 21.2443 8.93466H20.142V14H19.2642ZM25.544 14.0966C25.2675 14.0966 25.0175 14.0455 24.794 13.9432C24.5705 13.839 24.3935 13.6884 24.2628 13.4915C24.134 13.2945 24.0696 13.053 24.0696 12.767C24.0696 12.5208 24.117 12.3182 24.2116 12.1591C24.3063 12 24.4342 11.8741 24.5952 11.7812C24.7562 11.6884 24.9361 11.6184 25.1349 11.571C25.3338 11.5237 25.5365 11.4877 25.7429 11.4631C26.0043 11.4328 26.2164 11.4081 26.3793 11.3892C26.5421 11.3684 26.6605 11.3352 26.7344 11.2898C26.8082 11.2443 26.8452 11.1705 26.8452 11.0682V11.0483C26.8452 10.8002 26.7751 10.608 26.6349 10.4716C26.4967 10.3352 26.2902 10.267 26.0156 10.267C25.7296 10.267 25.5043 10.3305 25.3395 10.4574C25.1766 10.5824 25.0639 10.7216 25.0014 10.875L24.2031 10.6932C24.2978 10.428 24.4361 10.214 24.6179 10.0511C24.8016 9.88636 25.0128 9.76705 25.2514 9.69318C25.4901 9.61742 25.741 9.57955 26.0043 9.57955C26.1785 9.57955 26.3632 9.60038 26.5582 9.64205C26.7552 9.68182 26.9389 9.75568 27.1094 9.86364C27.2817 9.97159 27.4228 10.1259 27.5327 10.3267C27.6425 10.5256 27.6974 10.7841 27.6974 11.1023V14H26.8679V13.4034H26.8338C26.7789 13.5133 26.6965 13.6212 26.5866 13.7273C26.4768 13.8333 26.3357 13.9214 26.1634 13.9915C25.991 14.0616 25.7846 14.0966 25.544 14.0966ZM25.7287 13.4148C25.9635 13.4148 26.1643 13.3684 26.331 13.2756C26.4995 13.1828 26.6274 13.0616 26.7145 12.9119C26.8035 12.7604 26.848 12.5985 26.848 12.4261V11.8636C26.8177 11.8939 26.759 11.9223 26.6719 11.9489C26.5866 11.9735 26.4891 11.9953 26.3793 12.0142C26.2694 12.0312 26.1624 12.0473 26.0582 12.0625C25.9541 12.0758 25.867 12.0871 25.7969 12.0966C25.6321 12.1174 25.4815 12.1525 25.3452 12.2017C25.2107 12.2509 25.1027 12.322 25.0213 12.4148C24.9418 12.5057 24.902 12.6269 24.902 12.7784C24.902 12.9886 24.9796 13.1477 25.1349 13.2557C25.2902 13.3617 25.4882 13.4148 25.7287 13.4148ZM31.593 12.1903V9.63636H32.4453V14H31.6101V13.2443H31.5646C31.4643 13.4773 31.3033 13.6714 31.0817 13.8267C30.862 13.9801 30.5883 14.0568 30.2607 14.0568C29.9804 14.0568 29.7322 13.9953 29.5163 13.8722C29.3023 13.7472 29.1338 13.5625 29.0107 13.3182C28.8894 13.0739 28.8288 12.7718 28.8288 12.4119V9.63636H29.6783V12.3097C29.6783 12.607 29.7607 12.8437 29.9254 13.0199C30.0902 13.196 30.3042 13.2841 30.5675 13.2841C30.7266 13.2841 30.8847 13.2443 31.0419 13.1648C31.201 13.0852 31.3326 12.965 31.4368 12.804C31.5429 12.643 31.5949 12.4384 31.593 12.1903ZM36.8565 10.7017L36.0866 10.8381C36.0545 10.7396 36.0033 10.6458 35.9332 10.5568C35.8651 10.4678 35.7723 10.3949 35.6548 10.3381C35.5374 10.2812 35.3906 10.2528 35.2145 10.2528C34.974 10.2528 34.7732 10.3068 34.6122 10.4148C34.4512 10.5208 34.3707 10.6581 34.3707 10.8267C34.3707 10.9725 34.4247 11.09 34.5327 11.179C34.6406 11.268 34.8149 11.3409 35.0554 11.3977L35.7486 11.5568C36.1501 11.6496 36.4493 11.7926 36.6463 11.9858C36.8433 12.179 36.9418 12.4299 36.9418 12.7386C36.9418 13 36.866 13.233 36.7145 13.4375C36.5649 13.6402 36.3556 13.7992 36.0866 13.9148C35.8196 14.0303 35.5099 14.0881 35.1577 14.0881C34.669 14.0881 34.2704 13.9839 33.9616 13.7756C33.6529 13.5653 33.4635 13.267 33.3935 12.8807L34.2145 12.7557C34.2656 12.9697 34.3707 13.1316 34.5298 13.2415C34.6889 13.3494 34.8963 13.4034 35.152 13.4034C35.4304 13.4034 35.6529 13.3456 35.8196 13.2301C35.9863 13.1127 36.0696 12.9697 36.0696 12.8011C36.0696 12.6648 36.0185 12.5502 35.9162 12.4574C35.8158 12.3646 35.6615 12.2945 35.4531 12.2472L34.7145 12.0852C34.3073 11.9924 34.0062 11.8447 33.8111 11.642C33.6179 11.4394 33.5213 11.1828 33.5213 10.8722C33.5213 10.6146 33.5933 10.3892 33.7372 10.196C33.8812 10.0028 34.08 9.85227 34.3338 9.74432C34.5876 9.63447 34.8783 9.57955 35.206 9.57955C35.6776 9.57955 36.0488 9.68182 36.3196 9.88636C36.5904 10.089 36.7694 10.3608 36.8565 10.7017ZM39.7564 14.0881C39.3265 14.0881 38.9562 13.9962 38.6456 13.8125C38.3369 13.6269 38.0982 13.3665 37.9297 13.0312C37.763 12.6941 37.6797 12.2992 37.6797 11.8466C37.6797 11.3996 37.763 11.0057 37.9297 10.6648C38.0982 10.3239 38.3331 10.0578 38.6342 9.86648C38.9373 9.67519 39.2914 9.57955 39.6967 9.57955C39.9429 9.57955 40.1816 9.62027 40.4126 9.7017C40.6437 9.78314 40.8511 9.91098 41.0348 10.0852C41.2185 10.2595 41.3634 10.4858 41.4695 10.7642C41.5755 11.0407 41.6286 11.3769 41.6286 11.7727V12.0739H38.1598V11.4375H40.7962C40.7962 11.214 40.7507 11.0161 40.6598 10.8438C40.5689 10.6695 40.4411 10.5322 40.2763 10.4318C40.1134 10.3314 39.9221 10.2812 39.7024 10.2812C39.4638 10.2812 39.2554 10.34 39.0774 10.4574C38.9013 10.5729 38.7649 10.7244 38.6683 10.9119C38.5736 11.0975 38.5263 11.2992 38.5263 11.517V12.0142C38.5263 12.3059 38.5774 12.554 38.6797 12.7585C38.7839 12.9631 38.9287 13.1193 39.1143 13.2273C39.3 13.3333 39.5168 13.3864 39.7649 13.3864C39.9259 13.3864 40.0727 13.3636 40.2053 13.3182C40.3378 13.2708 40.4524 13.2008 40.549 13.108C40.6456 13.0152 40.7195 12.9006 40.7706 12.7642L41.5746 12.9091C41.5102 13.1458 41.3946 13.3532 41.228 13.5312C41.0632 13.7074 40.8558 13.8447 40.6058 13.9432C40.3577 14.0398 40.0746 14.0881 39.7564 14.0881Z" fill="white"/>
                            </g>
                            <defs>
                                <clipPath id="bgblur_0_4817_1549_clip_path" transform="translate(4 4)"><path d="M42 0.5C46.1421 0.5 49.5 3.85786 49.5 8V21.5H8C3.85787 21.5 0.5 18.1421 0.5 14V0.5H42Z"/></clipPath>
                            </defs>
                        </svg>
                        
                        <!-- Hover play state (large) -->
                        <svg class="play-icon hover-icon" width="58" height="30" viewBox="0 0 43 22" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                            <foreignObject x="-4" y="-4" width="51" height="30"><div xmlns="http://www.w3.org/1999/xhtml" style="backdrop-filter:blur(2px);clip-path:url(#bgblur_0_5243_465_clip_path);height:100%;width:100%"></div></foreignObject>
                            <g data-figma-bg-blur-radius="4">
                                <foreignObject x="-4" y="-4" width="51" height="30"><div xmlns="http://www.w3.org/1999/xhtml" style="backdrop-filter:blur(2px);clip-path:url(#bgblur_1_5243_465_clip_path);height:100%;width:100%"></div></foreignObject>
                                <g data-figma-bg-blur-radius="4">
                                    <path d="M35 0.5C39.1421 0.5 42.5 3.85786 42.5 8V21.5H8C3.85787 21.5 0.5 18.1421 0.5 14V0.5H35Z" fill="#242424"/>
                                    <!-- Left border -->
                                    <path d="M0.5 0.5V14C0.5 18.1421 3.85787 21.5 8 21.5" stroke="#3F3F46" fill="none"/>
                                    <!-- Bottom border -->
                                    <path d="M8 21.5H42.5" stroke="#3F3F46" fill="none"/>
                                    <path d="M13.2111 10.1055C13.9482 10.4741 13.9482 11.5259 13.2111 11.8944L10.4472 13.2763C9.78231 13.6088 9 13.1253 9 12.3819L9 9.61799C9 8.87461 9.78231 8.39111 10.4472 8.72356L13.2111 10.1055Z" fill="white"/>
                                    <path d="M19.6001 14V8.18182H21.674C22.1267 8.18182 22.5017 8.2642 22.799 8.42898C23.0964 8.59375 23.3189 8.81913 23.4666 9.10511C23.6143 9.3892 23.6882 9.70928 23.6882 10.0653C23.6882 10.4233 23.6134 10.7453 23.4638 11.0312C23.3161 11.3153 23.0926 11.5407 22.7933 11.7074C22.496 11.8722 22.1219 11.9545 21.6712 11.9545H20.245V11.2102H21.5916C21.8776 11.2102 22.1096 11.161 22.2876 11.0625C22.4657 10.9621 22.5964 10.8258 22.6797 10.6534C22.763 10.4811 22.8047 10.285 22.8047 10.0653C22.8047 9.84564 22.763 9.65057 22.6797 9.48011C22.5964 9.30966 22.4647 9.17614 22.2848 9.07955C22.1068 8.98295 21.8719 8.93466 21.5803 8.93466H20.478V14H19.6001ZM25.4986 8.18182V14H24.6491V8.18182H25.4986ZM27.9112 14.0966C27.6347 14.0966 27.3847 14.0455 27.1612 13.9432C26.9377 13.839 26.7607 13.6884 26.63 13.4915C26.5012 13.2945 26.4368 13.053 26.4368 12.767C26.4368 12.5208 26.4841 12.3182 26.5788 12.1591C26.6735 12 26.8014 11.8741 26.9624 11.7812C27.1233 11.6884 27.3033 11.6184 27.5021 11.571C27.701 11.5237 27.9036 11.4877 28.1101 11.4631C28.3714 11.4328 28.5836 11.4081 28.7464 11.3892C28.9093 11.3684 29.0277 11.3352 29.1016 11.2898C29.1754 11.2443 29.2124 11.1705 29.2124 11.0682V11.0483C29.2124 10.8002 29.1423 10.608 29.0021 10.4716C28.8639 10.3352 28.6574 10.267 28.3828 10.267C28.0968 10.267 27.8714 10.3305 27.7067 10.4574C27.5438 10.5824 27.4311 10.7216 27.3686 10.875L26.5703 10.6932C26.665 10.428 26.8033 10.214 26.9851 10.0511C27.1688 9.88636 27.38 9.76705 27.6186 9.69318C27.8572 9.61742 28.1082 9.57955 28.3714 9.57955C28.5457 9.57955 28.7304 9.60038 28.9254 9.64205C29.1224 9.68182 29.3061 9.75568 29.4766 9.86364C29.6489 9.97159 29.79 10.1259 29.8999 10.3267C30.0097 10.5256 30.0646 10.7841 30.0646 11.1023V14H29.2351V13.4034H29.201C29.1461 13.5133 29.0637 13.6212 28.9538 13.7273C28.844 13.8333 28.7029 13.9214 28.5305 13.9915C28.3582 14.0616 28.1518 14.0966 27.9112 14.0966ZM28.0959 13.4148C28.3307 13.4148 28.5315 13.3684 28.6982 13.2756C28.8667 13.1828 28.9946 13.0616 29.0817 12.9119C29.1707 12.7604 29.2152 12.5985 29.2152 12.4261V11.8636C29.1849 11.8939 29.1262 11.9223 29.0391 11.9489C29.0537 11.9735 28.8563 11.9953 28.7464 12.0142C28.6366 12.0312 28.5296 12.0473 28.4254 12.0625C28.3213 12.0758 28.2341 12.0871 28.1641 12.0966C27.9993 12.1174 27.8487 12.1525 27.7124 12.2017C27.5779 12.2509 27.4699 12.322 27.3885 12.4148C27.3089 12.5057 27.2692 12.6269 27.2692 12.7784C27.2692 12.9886 27.3468 13.1477 27.5021 13.2557C27.6574 13.3617 27.8554 13.4148 28.0959 13.4148ZM31.5767 15.6364C31.4498 15.6364 31.3343 15.6259 31.2301 15.6051C31.1259 15.5862 31.0483 15.5653 30.9972 15.5426L31.2017 14.8466C31.357 14.8883 31.4953 14.9063 31.6165 14.9006C31.7377 14.8949 31.8447 14.8494 31.9375 14.7642C32.0322 14.679 32.1155 14.5398 32.1875 14.3466L32.2926 14.0568L30.696 9.63636H31.6051L32.7102 13.0227H32.7557L33.8608 9.63636H34.7727L32.9744 14.5824C32.8911 14.8097 32.785 15.0019 32.6562 15.1591C32.5275 15.3182 32.3741 15.4375 32.196 15.517C32.018 15.5966 31.8116 15.6364 31.5767 15.6364Z" fill="white"/>
                                </g>
                            </g>
                            <defs>
                                <clipPath id="bgblur_0_5243_465_clip_path" transform="translate(4 4)"><path d="M0 0H35C39.4183 0 43 3.58172 43 8V22H8C3.58172 22 0 18.4183 0 14V0Z"/></clipPath>
                                <clipPath id="bgblur_1_5243_465_clip_path" transform="translate(4 4)"><path d="M35 0.5C39.1421 0.5 42.5 3.85786 42.5 8V21.5H8C3.85787 21.5 0.5 18.1421 0.5 14V0.5H35Z"/></clipPath>
                            </defs>
                        </svg>
                    </button>
                </div>
                <div class="color-picker-container">
                    <div class="color-picker-button" id="color-picker-button">
                        <!-- <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10c1.38 0 2.5-1.12 2.5-2.5 0-.61-.23-1.21-.64-1.67-.08-.09-.13-.21-.13-.33 0-.28.22-.5.5-.5h3.77C20.66 17 22 15.66 22 14V8.5C22 4.91 18.09 1 14.5 1l-.5.01c-.56 0-1 .45-1 1C13 2.56 12.56 3 12 3s-1-.44-1-1c0-.55-.45-1-1-1-.17 0-.33.04-.5.01zM8.5 8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5zm3-4c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5zm4.5 2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5z" fill="currentColor"/>
                        </svg> -->
                    </div>
                    <span class="color-hex-display" id="color-hex-display">#FFFFFF</span>
                    <input type="color" id="color-picker-input" value="#ffffff" style="position: absolute; top: 0; right: 0; width: 1px; height: 1px; opacity: 0; border: none; padding: 0;">
                </div>
                
            </div>

            <div class="controls-section">
                <div style="display: flex; flex-direction: row; align-items: center; gap: 26px; margin-bottom: 8px; min-width: 90px;">
                    <div class="control-group">
                        <label class="control-label">Style</label>
                        <div class="custom-select-wrapper">
                            <div class="select-tooltip" id="select-tooltip">Coming soon</div>
                            <select class="select-input select-input--small" id="style-select">
                                <option value="typing">Typing</option>
                                <option value="scale">Scale</option>
                                <option value="rotate" disabled>Rotate</option>
                                <option value="fade" disabled>Fade</option>
                                <option value="slide" disabled>Slide</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-group">
                        <label class="control-label" style="margin-bottom: 6px;" id="type-by-label">Type by</label>
                        <div class="radio-group">
                            <label class="radio-option">
                                <input type="radio" name="type-by" value="letter" checked>
                                <span class="radio-text">Letter</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="type-by" value="word">
                                <span class="radio-text">Word</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="control-group" id="direction-control">
                    <label class="control-label" id="direction-label">Direction</label>
                    <div class="radio-group">
                        <label class="radio-option">
                            <input type="radio" name="direction" value="forward" checked>
                            <span class="radio-text">Forward</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="direction" value="backwards">
                            <span class="radio-text">Backwards</span>
                        </label>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Duration <span style="color: #A1A1AA; font-size: 13px; font-weight: 300;">(ms)</span> </label>
                    <div class="duration-container">
                        <div class="duration-input-wrapper">
                            
                            <svg width="12" height="12" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6.91667 4.41667C6.91667 6.02667 5.61 7.33333 4 7.33333C2.39 7.33333 1.08334 6.02667 1.08334 4.41667C1.08334 2.80667 2.39 1.5 4 1.5C5.61 1.5 6.91667 2.80667 6.91667 4.41667Z" stroke="#A1A1AA" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M4 2.66663V4.33329" stroke="#A1A1AA" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M3 0.666626H5" stroke="#A1A1AA" stroke-width="0.5" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
        
                            <input type="number" class="duration-input duration-input--small" id="duration-input" value="1000" min="100" max="10000">
                            <div class="duration-arrows" id="duration-arrows">
                                <svg width="12" height="12" viewBox="0 0 5 8" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M2.50006 -5.72205e-05L0 2.5H5.00011L2.50006 -5.72205e-05Z" fill="#FEF7FF"/>
                                    <path d="M2.50006 8.00018L0 5.50012H5.00011L2.50006 8.00018Z" fill="#FEF7FF"/>
                                </svg>
                            </div>
                                
                        </div>
                    
                        <!-- <span style="color: #666; font-size: 11px; margin-left: -48px; z-index: 2;">ms</span> -->
                    </div>
                </div>
            </div> 
                <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 18px;">   
                    <button class="create-btn" id="create-btn">
                        <svg class="create-btn-svg" width="15" height="15" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g clip-path="url(#clip0_5137_30)">
                            <path d="M6.23744 3.05543L5 1.81799L3.76256 3.05543L5 4.29287L6.23744 3.05543Z" stroke="white" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8.18198 4.99997L6.94454 3.76254L5.70711 4.99997L6.94454 6.23741L8.18198 4.99997Z" stroke="white" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M6.23744 6.94452L5 5.70708L3.76256 6.94452L5 8.18195L6.23744 6.94452Z" stroke="white" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M4.29289 4.99997L3.05546 3.76254L1.81802 4.99997L3.05546 6.23741L4.29289 4.99997Z" stroke="white" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                            <defs>
                            <clipPath id="clip0_5137_30">
                            <rect width="6" height="6" fill="white" transform="translate(5 0.757324) rotate(45)"/>
                            </clipPath>
                            </defs>
                        </svg>
                        <div class="spinner" id="create-btn-spinner" style="display: none;"></div>
                        <span id="create-btn-text">Create component</span>
                    </button>
                    <button class="export-json-btn" id="export-json-btn" disabled>
                        Export as JSON
                    </button>
                </div> 
        </div>

        <div class="footer">
            <span class="beta-version" id="beta-version">
                <span class="beta-text">Beta 1.0</span>
                <div class="credits-tooltip" id="credits-tooltip">
                    <span>Designed by </span><a href="https://hellokene.com/" target="_blank" class="credit-link">kene</a><span>. Developed by </span><a href="https://sarah-adewale.netlify.app/" target="_blank" class="credit-link">sarah</a>
                </div>
            </span>
            <a href="#" id="feedback-link">Share feedback</a>
        </div>
    </div>

    <!-- Feedback Modal -->
    <div class="feedback-overlay" id="feedback-overlay">
        <div class="feedback-modal">
            <div class="feedback-title">Share feedback</div>
            <div class="feedback-input-container">
                <textarea class="feedback-textarea" id="feedback-textarea" placeholder="Start typing" maxlength="4000"></textarea>
                <div class="feedback-controls">
                    <div class="upload-section">
                        <button class="image-upload-btn" id="image-upload-btn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
                            </svg>
                        </button>
                        <div class="uploaded-file" id="uploaded-file" style="display: none;">
                            <span id="file-name"></span>
                            <button class="remove-file-btn" id="remove-file-btn"></button>
                        </div>
                        <input type="file" id="file-input" accept="image/*" style="display: none;">
                    </div>
                    <div class="word-counter" id="word-counter">0 of 400</div>
                </div>
            </div>
            <div class="feedback-error" id="word-limit-error" style="display: none; color: #ef4444; font-size: 12px; margin-top: 8px;">You have exceeded the 400 word limit.</div>
            <button class="feedback-submit-btn" id="feedback-submit-btn">Share feedback</button>
        </div>
    </div>
    <script>
        // UI State Management
        let currentStep = 1;
        let selectedText = '';
        let selectedLayerName = '';
        let animationSettings = {
            style: 'typing',
            typeBy: 'letter',
            direction: 'forward',
            duration: 1000,
            color: '#ffffff'
        };

        // Animation playback state
        let animationState = {
            isPlaying: false,
            isPaused: true,
            currentTimeout: null,
            currentIndex: 0
        };
        
        // Feedback Modal State
        let selectedFile = null;
        let maxWords = 400;

        // Get DOM elements dynamically to avoid null references
        function getDOMElements() {
            return {
                chooseSection: document.getElementById('choose-section'),
                previewSection: document.getElementById('preview-section'),
                selectedLayerDiv: document.getElementById('selected-layer'),
                layerNameSpan: document.getElementById('layer-name'),
                inputLabel: document.getElementById('input-label'),
                textInput: document.getElementById('text-input'),
                inputTooltip: document.getElementById('input-tooltip'),
                animateBtn: document.getElementById('animate-btn'),
                backBtn: document.getElementById('back-btn'),
                previewText: document.getElementById('preview-text'),
                styleSelect: document.getElementById('style-select'),
                selectTooltip: document.getElementById('select-tooltip'),
                durationInput: document.getElementById('duration-input'),
                createBtn: document.getElementById('create-btn'),
                step1: document.getElementById('step1'),
                step2: document.getElementById('step2')
            };
        }

        // Feedback modal functionality
        let feedbackState = {
            wordCount: 0,
            uploadedImage: null,
            isModalOpen: false,
            isProcessingUpload: false,
            isSetup: false
        };

        function openFeedbackModal() {
            const modal = document.getElementById('feedback-overlay');
            modal.style.display = 'flex';
            feedbackState.isModalOpen = true;
            
            // Focus on textarea
            const textarea = document.getElementById('feedback-textarea');
            textarea.focus();
        }

        function closeFeedbackModal() {
            const modal = document.getElementById('feedback-overlay');
            modal.style.display = 'none';
            feedbackState.isModalOpen = false;
            
            // Reset form
            document.getElementById('feedback-textarea').value = '';
            resetImageUpload();
            updateWordCount('');
        }

        function updateWordCount(text) {
            const words = text.trim().split(/\s+/).filter(word => word.length > 0);
            feedbackState.wordCount = text.trim() === '' ? 0 : words.length;
            
            const counter = document.getElementById('word-counter');
            const remaining = 400 - feedbackState.wordCount;
            
            if (feedbackState.wordCount > 400) {
                counter.textContent = `${feedbackState.wordCount} of 400`;
                counter.style.color = '#ef4444';
                document.getElementById('word-limit-error').style.display = 'block';
            } else {
                counter.textContent = `${feedbackState.wordCount} of 400`;
                counter.style.color = '#6B7280';
                document.getElementById('word-limit-error').style.display = 'none';
            }
        }

        function handleImageUpload(event) {
            console.log('handleImageUpload called, isProcessingUpload:', feedbackState.isProcessingUpload);
            
            // Prevent double execution
            if (feedbackState.isProcessingUpload) {
                console.log('Already processing upload, ignoring...');
                return;
            }
            
            feedbackState.isProcessingUpload = true;
            console.log('Starting image upload processing...');
            
            const file = event.target.files[0];
            if (!file) {
                console.log('No file selected');
                feedbackState.isProcessingUpload = false;
                return;
            }
            
            console.log('File selected:', file.name);
            
            // Check file size (2MB limit)
            if (file.size > 2 * 1024 * 1024) {
                alert('Image must be less than 2MB in size');
                feedbackState.isProcessingUpload = false;
                return;
            }
            
            // Check if it's an image
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file');
                feedbackState.isProcessingUpload = false;
                return;
            }
            
            feedbackState.uploadedImage = file;
            
            // Update UI to show uploaded file
            const uploadBtn = document.getElementById('image-upload-btn');
            const uploadedFile = document.getElementById('uploaded-file');
            const fileName = document.getElementById('file-name');
            
            uploadBtn.style.display = 'none';
            uploadedFile.style.display = 'flex';
            fileName.textContent = file.name;
            
            // Reset processing flag after a short delay
            setTimeout(() => {
                feedbackState.isProcessingUpload = false;
            }, 100);
        }

        function resetImageUpload() {
            feedbackState.uploadedImage = null;
            feedbackState.isProcessingUpload = false;
            
            const uploadBtn = document.getElementById('image-upload-btn');
            const uploadedFile = document.getElementById('uploaded-file');
            const fileInput = document.getElementById('file-input');
            
            uploadBtn.style.display = 'flex';
            uploadedFile.style.display = 'none';
            
            // Reset file input
            fileInput.value = '';
        }

        // Color picker functionality
        function initializeColorPicker() {
            const colorButton = document.getElementById('color-picker-button');
            const colorInput = document.getElementById('color-picker-input');
            const colorHexDisplay = document.getElementById('color-hex-display');
            
            if (!colorButton || !colorInput || !colorHexDisplay) return;
            
            // Initialize color picker with current animation settings color
            colorInput.value = animationSettings.color;
            updateTextColor(animationSettings.color);
            
            // Open color picker when button is clicked
            colorButton.addEventListener('click', (e) => {
                colorInput.click();
            });
            
            // Handle color change
            colorInput.addEventListener('change', (e) => {
                const newColor = e.target.value;
                updateTextColor(newColor);
            });
            
            // Also handle input event for real-time updates
            colorInput.addEventListener('input', (e) => {
                const newColor = e.target.value;
                updateTextColor(newColor);
            });
        }
        
        function updateTextColor(color) {
            // Update animation settings
            animationSettings.color = color;
            console.log('DEBUG: Color updated to:', color, 'animationSettings.color:', animationSettings.color);
            
            // Update hex display
            const colorHexDisplay = document.getElementById('color-hex-display');
            if (colorHexDisplay) {
                colorHexDisplay.textContent = color.toUpperCase();
            }
            
            // Update preview text color
            const previewText = document.getElementById('preview-text');
            if (previewText) {
                previewText.style.color = color;
            }
            
            // Update color picker button background to show current color
            const colorButton = document.getElementById('color-picker-button');
            if (colorButton) {
                colorButton.style.backgroundColor = color;
                colorButton.style.borderColor = color;
                // Adjust icon color based on background brightness
                const brightness = getBrightness(color);
                colorButton.style.color = brightness > 128 ? '#000000' : '#ffffff';
            }
        }
        
        function getBrightness(hexColor) {
            // Remove # if present
            const hex = hexColor.replace('#', '');
            // Convert to RGB
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            // Calculate brightness using luminance formula
            return (r * 299 + g * 587 + b * 114) / 1000;
        }
        
        function hexToRgbArray(hex) {
            // Remove # if present
            const cleanHex = hex.replace('#', '');
            // Convert to RGB values (0-255) then normalize to 0-1 for Lottie
            const r = parseInt(cleanHex.substr(0, 2), 16) / 255;
            const g = parseInt(cleanHex.substr(2, 2), 16) / 255;
            const b = parseInt(cleanHex.substr(4, 2), 16) / 255;
            return [r, g, b];
        }

        // Play/Pause functionality
        function initializePlayPauseButton() {
            const playPauseBtn = document.getElementById('play-pause-btn');
            if (!playPauseBtn) return;

            playPauseBtn.addEventListener('click', togglePlayPause);
            
            // Ensure button stays visible during animations
            setInterval(() => {
                const btn = document.getElementById('play-pause-btn');
                if (btn && (animationState.isPlaying || currentStep === 2)) {
                    btn.style.display = 'block';
                    btn.style.visibility = 'visible';
                    btn.style.opacity = '1';
                }
            }, 100);
        }

        function togglePlayPause() {
            const button = document.getElementById('play-pause-btn');
            
            if (animationState.isPaused) {
                // Start playing
                animationState.isPlaying = true;
                animationState.isPaused = false;
                button.setAttribute('data-state', 'playing');
                playAnimation();
            } else {
                // Pause
                animationState.isPlaying = false;
                animationState.isPaused = true;
                button.setAttribute('data-state', 'paused');
                pauseAnimation();
            }
        }

        function playAnimation() {
            // Clear any existing animation
            if (animationState.currentTimeout) {
                clearTimeout(animationState.currentTimeout);
            }
            
            // Set playing state
            animationState.isPlaying = true;
            animationState.isPaused = false;

            // Update button to show pause state
            const playPauseBtn = document.getElementById('play-pause-btn');
            if (playPauseBtn) {
                playPauseBtn.style.display = 'block';
                playPauseBtn.style.visibility = 'visible';
                playPauseBtn.style.opacity = '1';
                playPauseBtn.setAttribute('data-state', 'playing');
            }

            // Start the continuous animation loop
            const runAnimationLoop = () => {
                if (!animationState.isPlaying) return;
                
                applyAnimation();
                
                // Schedule next loop
                animationState.currentTimeout = setTimeout(() => {
                    if (animationState.isPlaying) {
                        runAnimationLoop();
                    }
                }, animationSettings.duration + 200); // Small gap between loops
            };
            
            runAnimationLoop();
        }

        function pauseAnimation() {
            // Set paused state
            animationState.isPlaying = false;
            animationState.isPaused = true;
            
            // Clear current timeout to stop animation
            if (animationState.currentTimeout) {
                clearTimeout(animationState.currentTimeout);
                animationState.currentTimeout = null;
            }
            
            // Clear scale animation timeouts
            if (window.scaleAnimationTimeouts) {
                window.scaleAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                window.scaleAnimationTimeouts = [];
            }
            
            // Clear rotate animation timeouts
            if (window.rotateAnimationTimeouts) {
                window.rotateAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                window.rotateAnimationTimeouts = [];
            }
            
            // Ensure complete text is visible when paused (especially for word-by-word animations)
            showCompleteTextWhenPaused();
            
            // Update button to show play state
            const playPauseBtn = document.getElementById('play-pause-btn');
            if (playPauseBtn) {
                playPauseBtn.setAttribute('data-state', 'paused');
            }
        }
        
        function showCompleteTextWhenPaused() {
            const elements = getDOMElements();
            if (!elements.previewText) return;
            
            const { style, typeBy } = animationSettings;
            
            // For scale and rotate animations with word-by-word, ensure complete text is visible
            if ((style === 'scale' && typeBy === 'word') ||
                (style === 'rotate' && typeBy === 'word')) {
                // Clear any animation classes and reset to show complete text
                elements.previewText.innerHTML = '';
                elements.previewText.className = 'preview-text';
                elements.previewText.textContent = selectedText.trim();
                elements.previewText.style.transform = style === 'rotate' ? 'rotate(0deg) scale(1)' : 'scale(1)';
                elements.previewText.style.opacity = '1';
                elements.previewText.style.animation = '';
            }
        }

        function resetToPlayState() {
            // Only called when user manually pauses or stops
            animationState.isPlaying = false;
            animationState.isPaused = true;
            animationState.currentIndex = 0;
            
            const button = document.getElementById('play-pause-btn');
            if (button) {
                button.setAttribute('data-state', 'paused');
            }
            
            // Clear any timeouts
            if (animationState.currentTimeout) {
                clearTimeout(animationState.currentTimeout);
                animationState.currentTimeout = null;
            }
            
            // Clear scale animation timeouts
            if (window.scaleAnimationTimeouts) {
                window.scaleAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                window.scaleAnimationTimeouts = [];
            }
            
            // Clear rotate animation timeouts
            if (window.rotateAnimationTimeouts) {
                window.rotateAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                window.rotateAnimationTimeouts = [];
            }
            
            // Ensure complete text is visible when reset
            showCompleteTextWhenPaused();
        }

        // Export animation configuration as Lottie JSON
        function exportAnimationAsJSON() {
            // Ensure we have the latest settings from the UI
            updateAnimation();
            
            // Ensure we have the latest color from the color picker
            const colorInput = document.getElementById('color-picker-input');
            if (colorInput) {
                animationSettings.color = colorInput.value;
            }
            
            console.log('DEBUG: Exporting JSON with color:', animationSettings.color);
            console.log('DEBUG: Color input value:', colorInput ? colorInput.value : 'not found');
            console.log('DEBUG: Color RGB array:', hexToRgbArray(animationSettings.color));
            console.log('DEBUG: Animation settings:', animationSettings);
            
            const animText = selectedText.trim() || "Sample text";
            const frameDuration = animationSettings.duration / 1000; // Convert to seconds
            const frameRate = 30;
            const totalFrames = Math.ceil(frameDuration * frameRate);
            
            // Pre-built letter shapes library with better readability
            function getLetterPath(char) {
                const letterPaths = {
                    'A': [[[5, 0], [5, 30], [15, 40], [25, 40], [35, 30], [35, 0]], [[10, 15], [30, 15]]],
                    'B': [[[5, 0], [5, 40], [25, 40], [30, 37], [30, 23], [25, 20], [30, 17], [30, 3], [25, 0], [5, 0]], [[5, 20], [25, 20]]],
                    'C': [[[30, 5], [25, 0], [15, 0], [10, 5], [10, 35], [15, 40], [25, 40], [30, 35]]],
                    'D': [[[5, 0], [5, 40], [20, 40], [30, 35], [30, 5], [20, 0], [5, 0]]],
                    'E': [[[5, 0], [5, 40], [30, 40]], [[5, 20], [25, 20]], [[5, 0], [30, 0]]],
                    'F': [[[5, 0], [5, 40], [30, 40]], [[5, 22], [25, 22]]],
                    'G': [[[30, 5], [25, 0], [15, 0], [10, 5], [10, 35], [15, 40], [25, 40], [30, 35], [30, 20], [22, 20]]],
                    'H': [[[5, 0], [5, 40]], [[30, 0], [30, 40]], [[5, 20], [30, 20]]],
                    'I': [[[17, 0], [17, 40]], [[10, 0], [25, 0]], [[10, 40], [25, 40]]],
                    'J': [[[25, 0], [25, 30], [20, 35], [15, 35], [10, 30]]],
                    'K': [[[5, 0], [5, 40]], [[30, 40], [5, 20]], [[15, 20], [30, 0]]],
                    'L': [[[5, 0], [5, 40]], [[5, 0], [28, 0]]],
                    'M': [[[5, 0], [5, 40], [17, 25], [29, 40], [29, 0]]],
                    'N': [[[5, 0], [5, 40], [30, 0], [30, 40]]],
                    'O': [[[15, 0], [25, 0], [30, 5], [30, 35], [25, 40], [15, 40], [10, 35], [10, 5], [15, 0]]],
                    'P': [[[5, 0], [5, 40], [25, 40], [30, 35], [30, 25], [25, 20], [5, 20]]],
                    'Q': [[[15, 0], [25, 0], [30, 5], [30, 35], [25, 40], [15, 40], [10, 35], [10, 5], [15, 0]], [[22, 25], [30, 10]]],
                    'R': [[[5, 0], [5, 40], [25, 40], [30, 35], [30, 25], [25, 20], [5, 20]], [[18, 20], [30, 0]]],
                    'S': [[[30, 5], [25, 0], [15, 0], [10, 5], [10, 15], [15, 20], [25, 20], [30, 25], [30, 35], [25, 40], [15, 40], [10, 35]]],
                    'T': [[[10, 40], [30, 40]], [[20, 0], [20, 40]]],
                    'U': [[[5, 40], [5, 10], [10, 5], [25, 5], [30, 10], [30, 40]]],
                    'V': [[[5, 40], [17, 0], [30, 40]]],
                    'W': [[[5, 40], [12, 0], [17, 15], [22, 0], [30, 40]]],
                    'X': [[[5, 0], [30, 40]], [[30, 0], [5, 40]]],
                    'Y': [[[5, 40], [17, 22], [30, 40]], [[17, 22], [17, 0]]],
                    'Z': [[[5, 40], [30, 40], [5, 0], [30, 0]]],
                    '0': [[[15, 0], [25, 0], [30, 5], [30, 35], [25, 40], [15, 40], [10, 35], [10, 5], [15, 0]]],
                    '1': [[[17, 0], [17, 40]], [[12, 35], [17, 40]]],
                    '2': [[[10, 35], [15, 40], [25, 40], [30, 35], [30, 25], [10, 0], [30, 0]]],
                    '3': [[[10, 35], [15, 40], [25, 40], [30, 35], [30, 25], [25, 20], [30, 15], [30, 5], [25, 0], [15, 0], [10, 5]], [[20, 20], [25, 20]]],
                    '4': [[[5, 40], [5, 15], [25, 15]], [[25, 0], [25, 40]]],
                    '5': [[[30, 40], [10, 40], [10, 22], [25, 22], [30, 17], [30, 5], [25, 0], [15, 0], [10, 5]]],
                    '6': [[[25, 40], [15, 40], [10, 35], [10, 5], [15, 0], [25, 0], [30, 5], [30, 15], [25, 20], [15, 20], [10, 15]]],
                    '7': [[[10, 40], [30, 40], [15, 0]]],
                    '8': [[[15, 0], [25, 0], [30, 5], [30, 15], [25, 20], [30, 25], [30, 35], [25, 40], [15, 40], [10, 35], [10, 25], [15, 20], [10, 15], [10, 5], [15, 0]], [[15, 20], [25, 20]]],
                    '9': [[[15, 0], [25, 0], [30, 5], [30, 35], [25, 40], [15, 40], [10, 35], [10, 25], [15, 20], [25, 20], [30, 25]]],
                    ' ': [], // Space has no path
                    '.': [[[17, 3], [23, 3], [23, 9], [17, 9], [17, 3]]],
                    ',': [[[17, 3], [23, 3], [23, 9], [17, 9], [17, 3]], [[20, 3], [18, -3]]],
                    '!': [[[18, 12], [22, 12], [22, 40], [18, 40], [18, 12]], [[17, 3], [23, 3], [23, 9], [17, 9], [17, 3]]],
                    '?': [[[10, 30], [15, 40], [25, 40], [30, 35], [30, 25], [20, 15], [20, 12]], [[17, 3], [23, 3], [23, 9], [17, 9], [17, 3]]]
                };
                
                return letterPaths[char.toUpperCase()] || [[[5, 0], [5, 40], [30, 40], [30, 0], [5, 0]]]; // Default rectangle
            }

            // Convert path points to Lottie path format
            function pointsToLottiePath(pathArray) {
                if (!pathArray || pathArray.length === 0) return null;
                
                const shapes = [];
                
                pathArray.forEach((path, pathIndex) => {
                    if (path.length < 2) return;
                    
                    const vertices = [];
                    const inTangents = [];
                    const outTangents = [];
                    
                    path.forEach(point => {
                        vertices.push(point);
                        inTangents.push([0, 0]); // No curves for now, just straight lines
                        outTangents.push([0, 0]);
                    });
                    
                    shapes.push({
                        "ty": "sh",
                        "ks": {
                            "a": 0,
                            "k": {
                                "i": inTangents,
                                "o": outTangents,
                                "v": vertices,
                                "c": true
                            },
                            "ix": 2
                        },
                        "nm": `Path ${pathIndex + 1}`,
                        "hd": false
                    });
                });
                
                return shapes;
            }

            // Generate character layers with actual letter shapes
            function generateCharacterLayers() {
                const layers = [];
                const chars = animText.split('');
                const charWidth = 45; // Width per character including spacing
                const startX = 256 - (animText.length * charWidth) / 2; // Center the text
                
                chars.forEach((char, index) => {
                    const charPaths = getLetterPath(char);
                    if (char === ' ' || charPaths.length === 0) return; // Skip spaces and empty chars
                    
                    const charX = startX + (index * charWidth);
                    const delayTime = (index / chars.length) * totalFrames;
                    const letterShapes = pointsToLottiePath(charPaths);
                    
                    if (!letterShapes) return;
                    
                    // Create shape items array
                    const shapeItems = [...letterShapes];
                    
                    // Add fill
                    shapeItems.push({
                        "ty": "fl",
                        "c": {"a": 0, "k": hexToRgbArray(animationSettings.color), "ix": 4},
                        "o": {"a": 0, "k": 100, "ix": 5},
                        "r": 1,
                        "bm": 0,
                        "nm": "Fill 1",
                        "hd": false
                    });
                    
                    // Add transform
                    shapeItems.push({
                        "ty": "tr",
                        "p": {"a": 0, "k": [0, 0], "ix": 2},
                        "a": {"a": 0, "k": [0, 0], "ix": 1},
                        "s": {"a": 0, "k": [100, 100], "ix": 3},
                        "r": {"a": 0, "k": 0, "ix": 6},
                        "o": {"a": 0, "k": 100, "ix": 7},
                        "sk": {"a": 0, "k": 0, "ix": 4},
                        "sa": {"a": 0, "k": 0, "ix": 5},
                        "nm": "Transform"
                    });
                    
                    layers.push({
                        "ddd": 0,
                        "ind": index + 1,
                        "ty": 4,
                        "nm": `Letter_${char}_${index}`,
                        "sr": 1,
                        "ks": {
                            "o": {
                                "a": 1,
                                "k": [
                                    {"t": 0, "s": [0]},
                                    {"t": Math.round(delayTime), "s": [0]},
                                    {"t": Math.round(delayTime + 5), "s": [100]}
                                ],
                                "ix": 11
                            },
                            "r": {
                                "a": 0,
                                "k": 0,
                                "ix": 10
                            },
                            "p": {
                                "a": 0,
                                "k": [charX, 256, 0],
                                "ix": 2
                            },
                            "a": {
                                "a": 0,
                                "k": [20, 20, 0],
                                "ix": 1
                            },
                            "s": {
                                "a": 0,
                                "k": [100, 100, 100],
                                "ix": 6
                            }
                        },
                        "ao": 0,
                        "shapes": [
                            {
                                "ty": "gr",
                                "it": shapeItems,
                                "nm": "Letter Group",
                                "np": letterShapes.length + 1,
                                "cix": 2,
                                "bm": 0,
                                "ix": 1,
                                "hd": false
                            }
                        ],
                        "ip": 0,
                        "op": totalFrames,
                        "st": 0,
                        "bm": 0
                    });
                });
                
                return layers;
            }

            // Generate opacity keyframes for shape-based animation
            function generateOpacityKeyframes() {
                const opacityFrames = [];
                const chars = animText.split('');
                const stepSize = totalFrames / chars.length;

                for (let i = 0; i <= chars.length; i++) {
                    const time = Math.round(i * stepSize);
                    const progress = i / chars.length;
                    
                    // Create typing effect with opacity
                    const opacity = animationSettings.direction === 'forward' 
                        ? Math.min(progress * 100, 100)
                        : Math.max((1 - progress) * 100, 0);

                    opacityFrames.push({
                        "t": time,
                        "s": [opacity],
                        "e": [opacity]
                    });
                }

                return opacityFrames;
            }
            
            // Create Lottie JSON structure with proper text layer format
            const textColor = hexToRgbArray(animationSettings.color);
            console.log('DEBUG: Text color for Lottie:', textColor);
            
            console.log('DEBUG: Using shape-based animation approach');
            
            const lottieData = {
                "v": "5.5.7",
                "fr": frameRate,
                "ip": 0,
                "op": totalFrames,
                "w": 512,
                "h": 512,
                "nm": `TextFx_${animationSettings.style}`,
                "ddd": 0,
                "assets": [],
                "layers": generateCharacterLayers(),
                "markers": [],
                "meta": {
                    "g": "TextFx Plugin v1.0",
                    "a": "Text Fx",
                    "k": animationSettings.style,
                    "d": `Text animation: ${animText}`,
                    "tc": ""
                }
            };
            
            // Note: Cursor removed to fix animation preview issue
            // The text animation should be the primary focus
            
            console.log('DEBUG: Final Lottie structure with all details:', lottieData);
            
            // Create and download the Lottie JSON file
            const jsonString = JSON.stringify(lottieData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            
            // Create filename in format: [text-layer-name/typed-word]-text-fx-lottie.json
            const textContent = selectedLayerName || selectedText.trim() || 'sample-text';
            const sanitizedText = textContent
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '') // Remove special characters except spaces and hyphens
                .replace(/\s+/g, '-') // Replace spaces with hyphens
                .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen
                .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
            
            link.download = `${sanitizedText}-text-fx-lottie.json`;
            document.body.appendChild(link);
            link.click();
            
            // Clean up
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log('Animation exported as Lottie JSON:', lottieData);
        }

        function submitFeedback() {
            const textarea = document.getElementById('feedback-textarea');
            const message = textarea.value.trim();
            
            if (!message) {
                alert('Please enter your feedback message');
                return;
            }
            
            if (feedbackState.wordCount > 400) {
                alert('Please reduce your message to 400 words or less');
                return;
            }
            
            // Create email content
            let emailBody = `Feedback from Text Fx Plugin User:\n\n${message}`;
            
            if (feedbackState.uploadedImage) {
                emailBody += `\n\n--- ATTACHMENT INFO ---\nImage attached: ${feedbackState.uploadedImage.name}\nFile size: ${(feedbackState.uploadedImage.size / 1024 / 1024).toFixed(2)} MB\nFile type: ${feedbackState.uploadedImage.type}\n\nNote: Please manually attach the selected image file to this email before sending.`;
            }
            
            // Create mailto link
            const subject = 'Text Fx Plugin Feedback';
            const mailtoLink = `mailto:akenenna@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(emailBody)}`;
            
            // Try to open email client
            try {
                window.open(mailtoLink, '_blank');
                
                // Show success message with attachment instructions if needed
                if (feedbackState.uploadedImage) {
                    setTimeout(() => {
                        alert(`Email opened! Please manually attach your image file:\n"${feedbackState.uploadedImage.name}"\nbefore sending the email.`);
                    }, 100);
                } else {
                    setTimeout(() => {
                        alert('Thank you for your feedback! Your email client should have opened with the message ready to send.');
                    }, 100);
                }
                
                closeFeedbackModal();
            } catch (error) {
                alert('Unable to open email client. Please copy the feedback and send it manually to akenenna@gmail.com');
            }
        }

        // Setup feedback modal event listeners
        function setupFeedbackModal() {
            // Prevent multiple setups
            if (feedbackState.isSetup) {
                console.log('Feedback modal already set up, skipping...');
                return;
            }
            
            console.log('Setting up feedback modal...');
            
            // Check if all required elements exist
            const feedbackLink = document.getElementById('feedback-link');
            const feedbackOverlay = document.getElementById('feedback-overlay');
            const feedbackTextarea = document.getElementById('feedback-textarea');
            const feedbackSubmitBtn = document.getElementById('feedback-submit-btn');
            const imageUploadBtn = document.getElementById('image-upload-btn');
            const fileInput = document.getElementById('file-input');
            const removeFileBtn = document.getElementById('remove-file-btn');
            const wordCounter = document.getElementById('word-counter');
            
            if (!feedbackLink || !feedbackOverlay || !feedbackTextarea || !feedbackSubmitBtn || !imageUploadBtn || !fileInput || !removeFileBtn || !wordCounter) {
                console.error('Some feedback modal elements not found:', {
                    feedbackLink, feedbackOverlay, feedbackTextarea, feedbackSubmitBtn, 
                    imageUploadBtn, fileInput, removeFileBtn, wordCounter
                });
                return;
            }
            
            feedbackState.isSetup = true;
            
            // Open modal when feedback link is clicked
            feedbackLink.addEventListener('click', (e) => {
                e.preventDefault();
                openFeedbackModal();
            });
            
            // Close modal when clicking outside
            feedbackOverlay.addEventListener('click', (e) => {
                if (e.target.id === 'feedback-overlay') {
                    closeFeedbackModal();
                }
            });
            
            // Handle textarea input for word counting
            feedbackTextarea.addEventListener('input', (e) => {
                updateWordCount(e.target.value);
            });
            
            // Handle form submission
            feedbackSubmitBtn.addEventListener('click', submitFeedback);
            
            // Handle image upload button click
            imageUploadBtn.addEventListener('click', (e) => {
                console.log('Image upload button clicked');
                e.preventDefault();
                e.stopPropagation();
                if (!feedbackState.uploadedImage && !feedbackState.isProcessingUpload) {
                    console.log('Opening file dialog...');
                    // Create a fresh file input each time to avoid event conflicts
                    const newFileInput = document.createElement('input');
                    newFileInput.type = 'file';
                    newFileInput.accept = 'image/*';
                    newFileInput.style.display = 'none';
                    
                    newFileInput.addEventListener('change', (event) => {
                        console.log('New file input change event');
                        if (event.target.files.length > 0) {
                            handleImageUpload(event);
                        }
                    });
                    
                    document.body.appendChild(newFileInput);
                    newFileInput.click();
                    
                    // Clean up after use
                    setTimeout(() => {
                        document.body.removeChild(newFileInput);
                    }, 1000);
                } else {
                    console.log('Image already uploaded or processing, ignoring click');
                }
            });
            
            // Note: File input change is now handled dynamically in the click handler above
            
            // Handle remove file button
            removeFileBtn.addEventListener('click', resetImageUpload);
            
            // Handle escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && feedbackState.isModalOpen) {
                    closeFeedbackModal();
                }
            });
        }

        // Initialize
        function init() {
            setupEventListeners();
            setupDurationArrows();
            setupFeedbackModal();
            initializeColorPicker();
            initializePlayPauseButton();
            
            // Initialize character counter
            updateCharacterCounter('');
            
            // Initialize the type-by label with default style
            updateTypeByLabel('typing');
            
            // Initialize direction section visibility based on default style
            handleStyleChange();
            
            updateUI();
            
            // Request current selection from Figma
            parent.postMessage({ pluginMessage: { type: 'get-selection' } }, '*');

                // Initial resize
            resizePluginToContent();
        }

        function setupEventListeners() {
            const elements = getDOMElements();
            
            // Check for null elements
            if (!elements.textInput) {
                return;
            }
            
            // Text input changes
            elements.textInput.addEventListener('input', handleTextInput);
            
            // Navigation
            if (elements.animateBtn) {
                elements.animateBtn.addEventListener('click', goToPreview);
            }
            
            if (elements.backBtn) {
                elements.backBtn.addEventListener('click', goToChoose);
            }
            
            // Animation controls
            if (elements.styleSelect) {
                elements.styleSelect.addEventListener('change', handleStyleChange);
            }
            
            // Add tooltip functionality for locked animations
            if (elements.styleSelect && elements.selectTooltip) {
                setupSelectTooltip();
            }
            
            if (elements.durationInput) {
                // Update animation settings when user types in duration field
                elements.durationInput.addEventListener('input', function() {
                    const newDuration = parseInt(elements.durationInput.value) || 1000;
                    animationSettings.duration = newDuration;
                    updateAnimation();
                });
                
                // Also handle when user finishes typing (on blur)
                elements.durationInput.addEventListener('blur', function() {
                    const newDuration = parseInt(elements.durationInput.value) || 1000;
                    // Ensure it's within valid range
                    const clampedDuration = Math.max(100, Math.min(10000, newDuration));
                    elements.durationInput.value = clampedDuration;
                    animationSettings.duration = clampedDuration;
                    updateAnimation();
                });
            }
            
            // Radio buttons
            document.querySelectorAll('input[name="type-by"]').forEach(radio => {
                radio.addEventListener('change', updateAnimation);
            });
            
            document.querySelectorAll('input[name="direction"]').forEach(radio => {
                radio.addEventListener('change', updateAnimation);
            });
            
            // Buttons
            if (elements.createBtn) {
                elements.createBtn.addEventListener('click', createComponent);
            }
            
            // Export JSON button - temporarily disabled
            const exportJsonBtn = document.getElementById('export-json-btn');
            if (exportJsonBtn) {
                // Disabled for now with coming soon state
                // exportJsonBtn.addEventListener('click', exportAnimationAsJSON);
                exportJsonBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Export JSON feature coming soon!');
                });
            }
            
            const closeBtn = document.getElementById('close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', closePlugin);
            }
            
            // Listen for messages from Figma
            window.onmessage = handleMessage;
            
            // Setup feedback modal
            setupFeedbackModal();
        }

        function handleMessage(event) {
            if (!event.data.pluginMessage) {
                return;
            }
            
            const { type, data } = event.data.pluginMessage;
            
            switch (type) {
                case 'selection-changed':
                    handleSelectionChange(data);
                    break;
                case 'text-content':
                    selectedText = data.content;
                    selectedLayerName = data.name;
                    updateUI();
                    break;
                case 'component-created':
                    handleComponentCreated(data);
                    break;
                case 'prototype-ready':
                    handlePrototypeReady(data);
                    break;
                default:
                    break;
            }
        }

        function handleSelectionChange(selection) {
            const elements = getDOMElements();
            
            if (selection && selection.type === 'TEXT') {
                // Text layer selected
                selectedLayerName = selection.name;
                selectedText = selection.content || '';
                
                // Check character limit for selected layer
                updateCharacterCounter(selectedText);
                
                // Update UI for selected layer state
                if (elements.textInput) {
                    elements.textInput.value = selectedText;
                    elements.textInput.disabled = true;
                    elements.textInput.style.opacity = '0.6';
                    elements.textInput.style.cursor = 'not-allowed';
                }
                
                // Setup tooltip for disabled input (shows only on hover of input field)
                if (elements.inputTooltip && elements.textInput) {
                    elements.inputTooltip.classList.add('show');
                    setupInputTooltipHover(elements.textInput, elements.inputTooltip);
                }
                
                // Update the input label to show layer is selected
                if (elements.inputLabel) {
                    const truncatedTitle = truncateLayerTitle(selectedLayerName);
                    elements.inputLabel.innerHTML = `"${truncatedTitle}" <span style="color: #fcfcfc;">selected</span>`;
                    elements.inputLabel.classList.add('selected');
                }
                
                // Hide selected layer display - we don't need it
                if (elements.selectedLayerDiv) {
                    elements.selectedLayerDiv.style.display = 'none';
                }
                
                // Enable animate button only if within character limit
                const cleanText = selectedText.replace(/\n|\r\n|\r/g, '');
                if (elements.animateBtn) {
                    elements.animateBtn.disabled = cleanText.length > 100;
                }
                
            } else {
                // No text layer selected - reset to input mode
                selectedLayerName = '';
                
                // Reset UI to input mode
                if (elements.textInput) {
                    elements.textInput.disabled = false;
                    elements.textInput.style.opacity = '1';
                    elements.textInput.style.cursor = 'text';
                    selectedText = elements.textInput.value;
                    updateCharacterCounter(selectedText);
                }
                
                // Hide tooltip when input is enabled
                if (elements.inputTooltip) {
                    elements.inputTooltip.classList.remove('show', 'hover-active');
                    cleanupInputTooltipHover(elements.textInput, elements.inputTooltip);
                }
                
                // Reset input label
                if (elements.inputLabel) {
                    elements.inputLabel.textContent = 'Select a text layer';
                    elements.inputLabel.classList.remove('selected');
                }
                
                // Hide selected layer display
                if (elements.selectedLayerDiv) {
                    elements.selectedLayerDiv.style.display = 'none';
                }
                
                // Update animate button state based on input content and character limit
                const cleanText = selectedText.replace(/\n|\r\n|\r/g, '');
                if (elements.animateBtn) {
                    elements.animateBtn.disabled = !selectedText.trim() || cleanText.length > 100;
                }
            }
            
            // Resize plugin to fit content changes
            if (currentStep === 1) {
                setTimeout(() => {
                    resizePluginToContent();
                }, 50);
            }
        }

        // Truncate layer title to 10 characters
        function truncateLayerTitle(title) {
            if (title.length <= 10) {
                return title;
            }
            return title.substring(0, 10) + '...';
        }

        // Character counting and validation
        function updateCharacterCounter(text) {
            const counter = document.getElementById('character-counter');
            const warning = document.getElementById('character-warning');
            const animateBtn = document.getElementById('animate-btn');
            
            if (!counter) return;
            
            // Remove line breaks from character count
            const cleanText = text.replace(/\n|\r\n|\r/g, '');
            const charCount = cleanText.length;
            const remaining = 100 - charCount;
            
            // Update counter display
            counter.textContent = `${charCount}/100`;
            
            // Update default duration based on character count
            updateDefaultDuration(charCount);
            
            // Update counter color based on character count
            counter.classList.remove('warning', 'error');
            if (charCount >= 100) {
                counter.classList.add('error');
                warning.style.display = 'block';
                if (animateBtn) animateBtn.disabled = true;
            } else if (charCount >= 80) {
                counter.classList.add('warning');
                warning.style.display = 'none';
                if (animateBtn) animateBtn.disabled = false;
            } else {
                warning.style.display = 'none';
                if (animateBtn && selectedText.trim()) animateBtn.disabled = false;
            }
        }

        function updateDefaultDuration(charCount) {
            const elements = getDOMElements();
            if (!elements.durationInput) return;
            
            // Determine default duration based on character count
            const defaultDuration = charCount <= 20 ? 1000 : 3000;
            
            // Only update if the current value is still a default value (1000 or 3000)
            // This prevents overriding user-customized durations
            const currentValue = parseInt(elements.durationInput.value) || 1000;
            const isDefaultValue = currentValue === 1000 || currentValue === 3000;
            
            if (isDefaultValue) {
                elements.durationInput.value = defaultDuration;
                animationSettings.duration = defaultDuration;
            }
        }

        // Update the handleTextInput function to include character counting
        function handleTextInput() {
            const elements = getDOMElements();
            
            // If user starts typing, clear any layer selection
            if (selectedLayerName) {
                selectedLayerName = '';
                if (elements.selectedLayerDiv) {
                    elements.selectedLayerDiv.style.display = 'none';
                }
                if (elements.inputLabel) {
                    elements.inputLabel.textContent = 'Select a text layer';
                    elements.inputLabel.style.color = '#fcfcfc';
                }
            }
            
            if (elements.textInput) {
                selectedText = elements.textInput.value;
                updateCharacterCounter(selectedText);
            }
            updateUI();
        }

        // Update the updateUI function
        function updateUI() {
            const elements = getDOMElements();
            
            // Only update if no layer is selected (to avoid overriding layer selection state)
            if (!selectedLayerName) {
                if (elements.selectedLayerDiv) {
                    elements.selectedLayerDiv.style.display = 'none';
                }
                if (elements.inputLabel) {
                    elements.inputLabel.textContent = 'Select a text layer';
                    elements.inputLabel.style.color = '#fcfcfc';
                }
                
                // Enable/disable animate button based on input content
                if (elements.animateBtn) {
                    elements.animateBtn.disabled = !selectedText.trim();
                }
                
                // Ensure input is enabled
                if (elements.textInput) {
                    elements.textInput.disabled = false;
                    elements.textInput.style.opacity = '1';
                    elements.textInput.style.cursor = 'text';
                }
                
                // Hide tooltip when input is enabled
                if (elements.inputTooltip) {
                    elements.inputTooltip.classList.remove('show', 'hover-active');
                    cleanupInputTooltipHover(elements.textInput, elements.inputTooltip);
                }
            }
            
            // Update preview text
            if (selectedText.trim() && elements.previewText) {
                elements.previewText.textContent = selectedText.trim();
            }
        }

        function goToPreview() {
            if (!selectedText.trim()) return;
            
            const elements = getDOMElements();
            if (!elements.chooseSection || !elements.previewSection) return;

            elements.chooseSection.classList.add('hiding');

            setTimeout(() => {
            currentStep = 2;
            elements.chooseSection.style.display = 'none';
            elements.chooseSection.classList.remove('hiding');
            elements.previewSection.style.display = 'block';
            
            // Update step indicators
            if (elements.step1) elements.step1.classList.remove('active');
            if (elements.step2) elements.step2.classList.add('active');
            
            // Set preview text
            if (elements.previewText) {
                elements.previewText.textContent = selectedText.trim();
                elements.previewText.style.color = animationSettings.color;
                elements.previewText.className = 'preview-text';
            }
            
            // Ensure play/pause button is visible
            const playPauseBtn = document.getElementById('play-pause-btn');
            if (playPauseBtn) {
                playPauseBtn.style.display = 'block';
                playPauseBtn.style.visibility = 'visible';
                playPauseBtn.setAttribute('data-state', 'playing');
            }
            
            // Automatically start the animation
            animationState.isPlaying = true;
            animationState.isPaused = false;
            
            // Start the continuous animation
            playAnimation();
            
            // Resize with animation after content change
            setTimeout(() => {
                resizePluginToContent();
            }, 0);
        }, 0); // Wait for fade out
        }

        function goToChoose() {
            const elements = getDOMElements();
            if (!elements.chooseSection || !elements.previewSection) return;
            
            elements.previewSection.classList.add('hiding');
            setTimeout(() => {
            currentStep = 1;
            elements.previewSection.style.display = 'none';
            elements.previewSection.classList.remove('hiding');
            elements.chooseSection.style.display = 'block';
            
            // Update step indicators
            if (elements.step1) elements.step1.classList.add('active');
            if (elements.step2) elements.step2.classList.remove('active');
            
            // Resize with animation after content change
            setTimeout(() => {
                resizePluginToContent();
            }, 0);
        }, 0); // Wait for fade out
        }

        function updateAnimation() {
            const elements = getDOMElements();
            
            // Get current settings from UI elements
            if (elements.styleSelect) {
                animationSettings.style = elements.styleSelect.value;
                
                // Update the type-by label dynamically based on selected style
                updateTypeByLabel(animationSettings.style);
            }
            
            const typeByRadio = document.querySelector('input[name="type-by"]:checked');
            if (typeByRadio) {
                animationSettings.typeBy = typeByRadio.value;
            }
            
            const directionRadio = document.querySelector('input[name="direction"]:checked');
            if (directionRadio) {
                animationSettings.direction = directionRadio.value;
            }
            
            // Get color from color picker
            const colorInput = document.getElementById('color-picker-input');
            if (colorInput) {
                animationSettings.color = colorInput.value;
            }
            
            // Get duration from input field (this ensures we always have the current value)
            if (elements.durationInput) {
                const inputDuration = parseInt(elements.durationInput.value) || 1000;
                animationSettings.duration = inputDuration;
            }
            
            // Don't animate if no text is selected
            if (!selectedText.trim()) {
                return;
            }
            
            // Clear existing animation
            if (elements.previewText) {
                elements.previewText.className = 'preview-text';
                elements.previewText.innerHTML = '';
                elements.previewText.style.color = animationSettings.color;
                
                // Stop any existing timeouts for typing animation
                if (window.currentTypingTimeout) {
                    clearTimeout(window.currentTypingTimeout);
                }
            }
            
            // Apply new animation with requestAnimationFrame for smoother transitions
            requestAnimationFrame(() => {
                applyAnimation();
            });
        }

        function applyAnimation() {
            const elements = getDOMElements();
            const text = selectedText.trim();
            const { style, typeBy, direction, duration } = animationSettings;
            
            if (!elements.previewText) return;
            
            // CRITICAL: Clear all previous animation timeouts when switching animations
            if (window.scaleAnimationTimeouts) {
                window.scaleAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                window.scaleAnimationTimeouts = [];
            }
            
            if (window.rotateAnimationTimeouts) {
                window.rotateAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                window.rotateAnimationTimeouts = [];
            }
            
            if (window.currentTypingTimeout) {
                clearTimeout(window.currentTypingTimeout);
                window.currentTypingTimeout = null;
            }
            
            // Clear any main animation timeout
            if (animationState.currentTimeout) {
                clearTimeout(animationState.currentTimeout);
                animationState.currentTimeout = null;
            }
            
            // CRITICAL: Reset preview text state completely before applying new animation
            elements.previewText.innerHTML = '';
            elements.previewText.className = 'preview-text';
            elements.previewText.style.transform = '';
            elements.previewText.style.opacity = '';
            elements.previewText.style.animation = '';
            
            // Set animation duration
            elements.previewText.style.animationDuration = `${duration}ms`;
            
            if (style === 'typing') {
                // Special handling for typing animation
                animateTyping(text, typeBy, direction, duration);
            } else if (style === 'scale') {
                // Special handling for scale animations
                // Map direction to scale type: forward = grow, backwards = shrink
                const scaleType = direction === 'forward' ? 'scale-grow' : 'scale-shrink';
                animateScale(text, typeBy, direction, duration, scaleType);
            } else if (style === 'rotate') {
                // Special handling for rotate animations
                animateRotate(text, typeBy, direction, duration, style);
            } else if (typeBy === 'letter') {
                // Animate by letter with stagger
                animateByLetter(text, style, direction, duration);
            } else {
                // Animate the whole text - back to original logic
                elements.previewText.textContent = text;
                elements.previewText.classList.add(`animate-${style}`);
            }
        }

        function animateTyping(text, typeBy, direction, duration) {
            const elements = getDOMElements();
            if (!elements.previewText) return;
            
            // Note: Cleanup is now handled in applyAnimation() - no need to clear here
            
            if (typeBy === 'letter') {
                // Character-by-character typing
                let displayedText = '';
                const chars = direction === 'forward' ? text.split('') : text.split('').reverse();
                const typingSpeed = Math.max(50, duration / chars.length); // Minimum 50ms per char
                
                // Create a container for the text and cursor
                const textContainer = document.createElement('span');
                const cursor = document.createElement('span');
                cursor.className = 'typing-cursor';
                cursor.textContent = '|';
                cursor.style.animation = 'blink-caret 0.75s step-end infinite';
                
                elements.previewText.appendChild(textContainer);
                elements.previewText.appendChild(cursor);
                
                let charIndex = 0;
                
                function typeNextChar() {
                    if (charIndex < chars.length) {
                        if (direction === 'forward') {
                            displayedText += chars[charIndex];
                        } else {
                            // For backwards, reveal letters from right to left
                            const visibleLength = charIndex + 1;
                            const startIndex = Math.max(0, text.length - visibleLength);
                            displayedText = text.substring(startIndex);
                        }
                        
                        textContainer.textContent = displayedText;
                        charIndex++;
                        window.currentTypingTimeout = setTimeout(typeNextChar, typingSpeed);
                    } else {
                        // Animation complete, hide cursor after a moment
                        window.currentTypingTimeout = setTimeout(() => {
                            if (cursor.parentNode) {
                                cursor.style.display = 'none';
                            }
                        }, 500);
                    }
                }
                
                // Start typing after a brief pause
                window.currentTypingTimeout = setTimeout(typeNextChar, 100);
                
            } else {
                // Word-by-word typing
                const words = text.split(' ');
                const typingSpeed = Math.max(200, duration / words.length); // Minimum 200ms per word
                
                // Create a container for the text and cursor
                const textContainer = document.createElement('span');
                const cursor = document.createElement('span');
                cursor.className = 'typing-cursor';
                cursor.textContent = '|';
                cursor.style.animation = 'blink-caret 0.75s step-end infinite';
                
                elements.previewText.appendChild(textContainer);
                elements.previewText.appendChild(cursor);
                
                let wordIndex = 0;
                
                function typeNextWord() {
                    if (wordIndex < words.length) {
                        if (direction === 'forward') {
                            textContainer.textContent = words.slice(0, wordIndex + 1).join(' ');
                        } else {
                            // For backwards, reveal words from right to left but in correct order
                            const wordsToShow = wordIndex + 1;
                            const startWordIndex = Math.max(0, words.length - wordsToShow);
                            textContainer.textContent = words.slice(startWordIndex).join(' ');
                        }
                        
                        wordIndex++;
                        window.currentTypingTimeout = setTimeout(typeNextWord, typingSpeed);
                    } else {
                        // Animation complete, hide cursor after a moment
                        window.currentTypingTimeout = setTimeout(() => {
                            if (cursor.parentNode) {
                                cursor.style.display = 'none';
                            }
                        }, 500);
                    }
                }
                
                // Start typing after a brief pause
                window.currentTypingTimeout = setTimeout(typeNextWord, 100);
            }
        }

        function animateByLetter(text, style, direction, duration) {
            const elements = getDOMElements();
            if (!elements.previewText) return;
            
            elements.previewText.innerHTML = '';
            const letters = text.split('');
            const staggerDelay = duration / (letters.length * 2);
            
            letters.forEach((letter, index) => {
                const span = document.createElement('span');
                span.className = 'letter';
                span.textContent = letter === ' ' ? '\u00A0' : letter; // Non-breaking space
                
                const delay = direction === 'forward' ? index * staggerDelay : (letters.length - 1 - index) * staggerDelay;
                span.style.animationDelay = `${delay}ms`;
                span.style.animationDuration = `${duration}ms`;
                
                // Use requestAnimationFrame for smoother animation application
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        span.classList.add(`animate-${style}`);
                    });
                }, delay);
                
                elements.previewText.appendChild(span);
            });
        }

        function animateScale(text, typeBy, direction, duration, style) {
            const elements = getDOMElements();
            if (!elements.previewText) return;

            // Note: Cleanup is now handled in applyAnimation() - no need to clear here

            if (typeBy === 'letter') {
                // Scale by sentence - whole text scales at once
                animateScaleBySentence(text, duration, style);
            } else {
                // Scale by word - each word scales as a unit
                animateScaleByWord(text, direction, duration, style);
            }
        }

        function animateScaleBySentence(text, duration, style) {
            const elements = getDOMElements();
            if (!elements.previewText) return;

            // Initialize timeout tracking
            if (!window.scaleAnimationTimeouts) {
                window.scaleAnimationTimeouts = [];
            }

            // Scale the entire sentence as one unit
            elements.previewText.textContent = text;
            elements.previewText.style.transformOrigin = 'center';
            elements.previewText.style.display = 'block';
            
            if (style === 'scale-grow') {
                // Start invisible and small
                elements.previewText.style.transform = 'scale(0)';
                elements.previewText.style.opacity = '0';
                
                // Apply grow animation
                requestAnimationFrame(() => {
                    if (!animationState.isPlaying) return; // Check if still playing
                    
                    elements.previewText.classList.add('animate-scale-grow');
                    elements.previewText.style.animationDuration = `${duration}ms`;
                    
                    // After animation completes, prepare for next loop
                    const timeout = setTimeout(() => {
                        if (!animationState.isPlaying) return; // Check if still playing
                        
                        if (elements.previewText) {
                            // Reset for next loop
                            elements.previewText.classList.remove('animate-scale-grow');
                            elements.previewText.style.transform = 'scale(1)';
                            elements.previewText.style.opacity = '1';
                            
                            // Wait a brief moment then restart the animation
                            const loopTimeout = setTimeout(() => {
                                if (!animationState.isPlaying) return; // Check if still playing
                                animateScaleBySentence(text, duration, style);
                            }, 200); // Brief pause between loops
                            
                            window.scaleAnimationTimeouts.push(loopTimeout);
                        }
                    }, duration);
                    window.scaleAnimationTimeouts.push(timeout);
                });
            } else if (style === 'scale-shrink') {
                // Start visible and normal size
                elements.previewText.style.transform = 'scale(1)';
                elements.previewText.style.opacity = '1';
                
                // Apply shrink animation
                requestAnimationFrame(() => {
                    if (!animationState.isPlaying) return; // Check if still playing
                    
                    elements.previewText.classList.add('animate-scale-shrink');
                    elements.previewText.style.animationDuration = `${duration}ms`;
                    
                    // After animation completes, prepare for next loop
                    const timeout = setTimeout(() => {
                        if (!animationState.isPlaying) return; // Check if still playing
                        
                        if (elements.previewText) {
                            // Remove animation class but stay in final state (invisible)
                            elements.previewText.classList.remove('animate-scale-shrink');
                            elements.previewText.style.transform = 'scale(0)';
                            elements.previewText.style.opacity = '0';
                            
                            // Wait longer to show invisible state, then reset and restart
                            const loopTimeout = setTimeout(() => {
                                if (!animationState.isPlaying) return; // Check if still playing
                                // Now reset to visible state (State A) and restart
                                elements.previewText.style.transform = 'scale(1)';
                                elements.previewText.style.opacity = '1';
                                animateScaleBySentence(text, duration, style);
                            }, 800); // Longer pause to show the "shrunk" state
                            
                            window.scaleAnimationTimeouts.push(loopTimeout);
                        }
                    }, duration);
                    window.scaleAnimationTimeouts.push(timeout);
                });
            }
        }

        function animateScaleByWord(text, direction, duration, style) {
            const elements = getDOMElements();
            if (!elements.previewText) return;

            // Initialize timeout tracking
            if (!window.scaleAnimationTimeouts) {
                window.scaleAnimationTimeouts = [];
            }

            const words = text.split(' ');
            
            // Optimized stagger timing for words
            const staggerDelay = Math.max(200, duration / words.length);
            
            // Calculate total time for all words to complete
            const animDuration = Math.min(duration * 0.8, 1000);
            const totalAnimationTime = (words.length - 1) * staggerDelay + animDuration;
            
            if (style === 'scale-grow') {
                // For scale-grow, start with empty text and progressively add words
                elements.previewText.textContent = '';
                elements.previewText.style.display = 'block';
                
                words.forEach((word, index) => {
                    const delay = direction === 'forward' 
                        ? index * staggerDelay 
                        : (words.length - 1 - index) * staggerDelay;
                    
                    const timeout = setTimeout(() => {
                        if (!animationState.isPlaying) return;
                        
                        // Create span for the word
                        const span = document.createElement('span');
                        span.textContent = word;
                        span.style.display = 'inline-block';
                        span.style.transformOrigin = 'center';
                        
                        // Add the word to preview
                        elements.previewText.appendChild(span);
                        
                        // Add space after word (except last word)
                        if (index < words.length - 1) {
                            const space = document.createTextNode(' ');
                            elements.previewText.appendChild(space);
                        }
                        
                        // Start grow animation
                        span.classList.add('animate-scale-grow');
                        span.style.animationDuration = `${animDuration}ms`;
                    }, delay);
                    
                    window.scaleAnimationTimeouts.push(timeout);
                });
            } else if (style === 'scale-shrink') {
                // For scale-shrink, start with full sentence and progressively remove words
                elements.previewText.innerHTML = '';
                elements.previewText.style.display = 'block';
                
                // Create all word spans first (visible state) with separate spaces
                const wordSpans = [];
                words.forEach((word, index) => {
                    const span = document.createElement('span');
                    span.textContent = word;
                    span.style.display = 'inline-block';
                    span.style.transformOrigin = 'center';
                    wordSpans.push(span);
                    elements.previewText.appendChild(span);
                    
                    // Add space after word (except last word) - space stays visible
                    if (index < words.length - 1) {
                        const space = document.createTextNode(' ');
                        elements.previewText.appendChild(space);
                    }
                });
                
                // Now animate each word to shrink out of view (spaces remain)
                // For shrink animation, we want last word to disappear first, then work backwards
                words.forEach((word, index) => {
                    const delay = direction === 'forward' 
                        ? (words.length - 1 - index) * staggerDelay  // Last word first (reversed)
                        : index * staggerDelay;
                    
                    const timeout = setTimeout(() => {
                        if (!animationState.isPlaying) return;
                        
                        const span = wordSpans[index];
                        if (span) {
                            // Start shrink animation (word disappears, space remains)
                            span.classList.add('animate-scale-shrink');
                            span.style.animationDuration = `${animDuration}ms`;
                            span.style.animationFillMode = 'forwards'; // Keep final state (invisible)
                        }
                    }, delay);
                    
                    window.scaleAnimationTimeouts.push(timeout);
                });
            }
            
            // Schedule the next loop after all words have finished animating
            const loopTimeout = setTimeout(() => {
                if (!animationState.isPlaying) return; // Check if still playing
                
                // Reset preview text for next loop
                elements.previewText.innerHTML = '';
                elements.previewText.className = 'preview-text';
                
                // Wait a brief moment then restart the animation
                const restartTimeout = setTimeout(() => {
                    if (!animationState.isPlaying) return; // Check if still playing
                    animateScaleByWord(text, direction, duration, style);
                }, 200); // Brief pause between loops
                
                window.scaleAnimationTimeouts.push(restartTimeout);
            }, totalAnimationTime + 200); // Wait for all animations to complete plus a small buffer
            
            window.scaleAnimationTimeouts.push(loopTimeout);
        }

        function animateRotate(text, typeBy, direction, duration, style) {
            const elements = getDOMElements();
            if (!elements.previewText) return;

            // Note: Cleanup is now handled in applyAnimation() - no need to clear here

            if (typeBy === 'letter') {
                // Rotate by sentence - whole text rotates at once
                animateRotateBySentence(text, duration, style, direction);
            } else {
                // Rotate by word - each word rotates as a unit
                animateRotateByWord(text, direction, duration, style);
            }
        }

        function animateRotateBySentence(text, duration, style, direction) {
            const elements = getDOMElements();
            if (!elements.previewText) return;

            // Initialize timeout tracking
            if (!window.rotateAnimationTimeouts) {
                window.rotateAnimationTimeouts = [];
            }

            // Set up the sentence
            elements.previewText.textContent = text;
            elements.previewText.style.transformOrigin = 'center';
            elements.previewText.style.display = 'block';
            
            // Apply the correct rotate animation based on direction
            const rotateClass = direction === 'backwards' ? 'animate-rotate-backwards' : 'animate-rotate';
            elements.previewText.classList.add(rotateClass);
            elements.previewText.style.animationDuration = `${duration}ms`;
            
            // Schedule next loop after animation completes
            const timeout = setTimeout(() => {
                if (!animationState.isPlaying) return; // Check if still playing
                
                if (elements.previewText) {
                    // Reset for next loop - remove both possible rotate classes
                    elements.previewText.classList.remove('animate-rotate', 'animate-rotate-backwards');
                    elements.previewText.style.transform = '';
                    elements.previewText.style.opacity = '';
                    
                    // Wait a brief moment then restart the animation
                    const loopTimeout = setTimeout(() => {
                        if (!animationState.isPlaying) return; // Check if still playing
                        animateRotateBySentence(text, duration, style, direction);
                    }, 200); // Brief pause between loops
                    
                    window.rotateAnimationTimeouts.push(loopTimeout);
                }
            }, duration);
            window.rotateAnimationTimeouts.push(timeout);
        }

        function animateRotateByWord(text, direction, duration, style) {
            const elements = getDOMElements();
            if (!elements.previewText) return;

            // Initialize timeout tracking
            if (!window.rotateAnimationTimeouts) {
                window.rotateAnimationTimeouts = [];
            }

            const words = text.split(' ');
            const staggerDelay = Math.max(200, duration / words.length);
            
            // Calculate total time for all words to complete
            const animDuration = Math.min(duration * 0.8, 1000);
            const totalTime = (words.length - 1) * staggerDelay + animDuration;

            // Start with empty text
            elements.previewText.textContent = '';
            elements.previewText.style.display = 'block';

            if (direction === 'forward') {
                // Forward: words appear left-to-right and are added in order
                words.forEach((word, index) => {
                    const delay = index * staggerDelay;
                    
                    const timeout = setTimeout(() => {
                        if (!animationState.isPlaying) return;
                        
                        // Create span for this word
                        const span = document.createElement('span');
                        span.className = 'letter';
                        span.textContent = word;
                        span.style.display = 'inline-block';
                        span.style.transformOrigin = 'center';
                        
                        // Add space before word (except first word)
                        if (elements.previewText.textContent.length > 0) {
                            elements.previewText.appendChild(document.createTextNode(' '));
                        }
                        
                        // Add the word to preview
                        elements.previewText.appendChild(span);
                        
                        // Start animation immediately
                        span.classList.add('animate-rotate');
                        span.style.animationDuration = `${animDuration}ms`;
                    }, delay);
                    
                    window.rotateAnimationTimeouts.push(timeout);
                });
            } else {
                // Backwards: words animate from right-to-left, but maintain correct positions
                // Pre-create all word spans in correct positions, but make them invisible
                const wordSpans = [];
                for (let i = 0; i < words.length; i++) {
                    const span = document.createElement('span');
                    span.className = 'letter';
                    span.textContent = words[i];
                    span.style.display = 'inline-block';
                    span.style.transformOrigin = 'center';
                    span.style.opacity = '0'; // Start invisible
                    
                    // Add space before word (except first word)
                    if (i > 0) {
                        elements.previewText.appendChild(document.createTextNode(' '));
                    }
                    
                    elements.previewText.appendChild(span);
                    wordSpans.push(span);
                }
                
                // Now animate words from right to left
                words.forEach((word, index) => {
                    const delay = (words.length - 1 - index) * staggerDelay;
                    
                    const timeout = setTimeout(() => {
                        if (!animationState.isPlaying) return;
                        
                        const span = wordSpans[index];
                        span.style.opacity = '1'; // Make visible
                        
                        // Start animation immediately
                        span.classList.add('animate-rotate-backwards');
                        span.style.animationDuration = `${animDuration}ms`;
                    }, delay);
                    
                    window.rotateAnimationTimeouts.push(timeout);
                });
            }
            
            // Schedule next loop after all words complete (like scale word animation)
            const loopTimeout = setTimeout(() => {
                if (!animationState.isPlaying) return;
                
                // Reset preview text for next loop
                elements.previewText.innerHTML = '';
                elements.previewText.className = 'preview-text';
                
                // Wait a brief moment then restart the animation
                const restartTimeout = setTimeout(() => {
                    if (!animationState.isPlaying) return;
                    animateRotateByWord(text, direction, duration, style);
                }, 200);
                
                window.rotateAnimationTimeouts.push(restartTimeout);
            }, totalTime + 200);
            
            window.rotateAnimationTimeouts.push(loopTimeout);
        }

        function createComponent() {
            // Show loading state
            setCreateButtonLoading(true);
            
            // Ensure we have the latest color from the color picker
            const colorInput = document.getElementById('color-picker-input');
            if (colorInput) {
                animationSettings.color = colorInput.value;
            }
            
            console.log('DEBUG: Creating component with color:', animationSettings.color);
            console.log('DEBUG: Full animation settings:', animationSettings);
            
            const componentData = {
                text: selectedText.trim(),
                layerName: selectedLayerName,
                animation: animationSettings
            };
            
            parent.postMessage({ 
                pluginMessage: { 
                    type: 'create-component', 
                    data: componentData 
                } 
            }, '*');
        }

        function setCreateButtonLoading(isLoading) {
            const createBtn = document.getElementById('create-btn');
            const spinner = document.getElementById('create-btn-spinner');
            const btnText = document.getElementById('create-btn-text');
            const btnSvg = document.querySelector('.create-btn-svg');
            
            if (isLoading) {
                createBtn.classList.add('loading');
                createBtn.disabled = true;
                spinner.style.display = 'block';
                btnText.textContent = 'Creating...';
                btnSvg.style.display = 'none';
            } else {
                createBtn.classList.remove('loading');
                createBtn.disabled = false;
                spinner.style.display = 'none';
                btnText.textContent = 'Create component';
                btnSvg.style.display = 'block';
            }
        }

        function handleComponentCreated(data) {
            // Always hide loading state first
            setCreateButtonLoading(false);
            
            if (data.success && data.prototyped) {
                // Show success feedback with prototype information
                showPrototypeSuccessMessage();
                
                // Note: Removed button success message - only showing at top now
            } else if (!data.success) {
                // Handle error case
                console.error('Component creation failed:', data.error);
                showErrorMessage(data.error || 'Failed to create component');
            }
        }
        
        function handlePrototypeReady(data) {
            console.log('Prototype is ready for component:', data.componentId);
            // Additional actions when prototype is fully ready
            showPrototypeInstructions();
        }
        
        function showPrototypeSuccessMessage() {
            // Create a temporary success indicator
            const successIndicator = document.createElement('div');
            successIndicator.innerHTML = 'Component created and prototyped!';
            successIndicator.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: #00D084;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 12px;
                z-index: 1000;
                animation: slideDown 0.3s ease-out;
            `;
            
            document.body.appendChild(successIndicator);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (successIndicator.parentNode) {
                    successIndicator.parentNode.removeChild(successIndicator);
                }
            }, 3000);
        }
        
        function showPrototypeInstructions() {
            console.log('TIP: Click the first variant or switch to prototype mode to see the animation!');
        }
        
        function showErrorMessage(message) {
            // Create error indicator
            const errorIndicator = document.createElement('div');
            errorIndicator.innerHTML = ` ${message}`;
            errorIndicator.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: #F24822;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 12px;
                z-index: 1000;
                animation: slideDown 0.3s ease-out;
            `;
            
            document.body.appendChild(errorIndicator);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (errorIndicator.parentNode) {
                    errorIndicator.parentNode.removeChild(errorIndicator);
                }
            }, 5000);
        }

        function updateTypeByLabel(style) {
            const typeByLabel = document.getElementById('type-by-label');
            if (!typeByLabel) return;
            
            // Map animation styles to their corresponding action words
            const styleLabels = {
                'typing': 'Type by',
                'fade': 'Fade by',
                'slide': 'Slide by',
                'scale': 'Scale by',
                'rotate': 'Rotate by'
            };
            
            // Special handling for scale and rotate animations - change options to Sentence/Word
            const typeByRadioContainer = document.querySelector('input[name="type-by"]').closest('.radio-group');
            if ((style === 'scale' || style === 'rotate') && typeByRadioContainer) {
                const letterLabel = typeByRadioContainer.querySelector('label:first-child .radio-text');
                const wordLabel = typeByRadioContainer.querySelector('label:last-child .radio-text');
                if (letterLabel) letterLabel.textContent = 'Sentence';
                if (wordLabel) wordLabel.textContent = 'Word';
            } else if (typeByRadioContainer) {
                // Reset to default for other animations
                const letterLabel = typeByRadioContainer.querySelector('label:first-child .radio-text');
                const wordLabel = typeByRadioContainer.querySelector('label:last-child .radio-text');
                if (letterLabel) letterLabel.textContent = 'Letter';
                if (wordLabel) wordLabel.textContent = 'Word';
            }
            
            // Update the label text
            typeByLabel.textContent = styleLabels[style] || 'Type by';
        }

        function handleStyleChange() {
            const styleSelect = document.getElementById('style-select');
            const directionControl = document.getElementById('direction-control');
            const directionLabel = document.getElementById('direction-label');
            
            if (styleSelect && directionControl && directionLabel) {
                const selectedStyle = styleSelect.value;
                const isScaleAnimation = selectedStyle === 'scale';
                
                if (isScaleAnimation) {
                    // For scale animations, change to "Type" and show Grow/Shrink options
                    directionLabel.textContent = 'Type';
                    directionControl.style.display = 'block';
                    
                    // Update radio options to show Grow/Shrink
                    const radioTexts = directionControl.querySelectorAll('.radio-text');
                    const forwardRadio = directionControl.querySelector('input[value="forward"]');
                    const backwardRadio = directionControl.querySelector('input[value="backwards"]');
                    
                    if (radioTexts.length >= 2) {
                        radioTexts[0].textContent = 'Grow';
                        radioTexts[1].textContent = 'Shrink';
                    }
                    
                    // Set default to Grow (forward)
                    if (forwardRadio) {
                        forwardRadio.checked = true;
                        animationSettings.direction = 'forward';
                    }
                } else {
                    // For other animations, use normal Direction with Forward/Backward
                    directionLabel.textContent = 'Direction';
                    directionControl.style.display = 'block';
                    
                    // Restore radio options to show Forward/Backward
                    const radioTexts = directionControl.querySelectorAll('.radio-text');
                    if (radioTexts.length >= 2) {
                        radioTexts[0].textContent = 'Forward';
                        radioTexts[1].textContent = 'Backward';
                    }
                }
                
                // Resize plugin window to accommodate the changed content height
                resizePluginToContent();
            }
            
            updateAnimation();
        }
        
        function setupSelectTooltip() {
            const elements = getDOMElements();
            const selectWrapper = elements.styleSelect.parentElement;
            
            // Remove automatic tooltip - user will see padlock emoji and disabled state
            // Tooltip is not needed since padlock emoji is clear visual indicator
            // and disabled options can't be selected anyway
            
            // Only show tooltip if somehow a disabled option gets selected (shouldn't happen)
            elements.styleSelect.addEventListener('change', () => {
                const disabledStyles = ['fade', 'slide'];
                if (disabledStyles.includes(elements.styleSelect.value)) {
                    // Briefly show tooltip to explain why selection was reverted
                    elements.selectTooltip.classList.add('show');
                    setTimeout(() => {
                        elements.selectTooltip.classList.remove('show');
                    }, 2000);
                }
            });
        }

        function setupInputTooltipHover(inputElement, tooltipElement) {
            if (!inputElement || !tooltipElement) return;
            
            // Store references for cleanup
            inputElement._hoverHandlers = {
                mouseenter: () => {
                    if (inputElement.disabled) {
                        tooltipElement.classList.add('hover-active');
                    }
                },
                mouseleave: () => {
                    tooltipElement.classList.remove('hover-active');
                }
            };
            
            // Add hover listeners only to the input field
            inputElement.addEventListener('mouseenter', inputElement._hoverHandlers.mouseenter);
            inputElement.addEventListener('mouseleave', inputElement._hoverHandlers.mouseleave);
        }
        
        function cleanupInputTooltipHover(inputElement, tooltipElement) {
            if (!inputElement || !inputElement._hoverHandlers) return;
            
            // Remove hover listeners
            inputElement.removeEventListener('mouseenter', inputElement._hoverHandlers.mouseenter);
            inputElement.removeEventListener('mouseleave', inputElement._hoverHandlers.mouseleave);
            
            // Clear references
            delete inputElement._hoverHandlers;
        }

        function closePlugin() {
            parent.postMessage({ pluginMessage: { type: 'close' } }, '*');
        }

        // Custom duration input arrows functionality
        function setupDurationArrows() {
            const durationInput = document.getElementById('duration-input');
            const durationArrows = document.getElementById('duration-arrows');
            
            console.log('Setting up duration arrows:', { durationInput, durationArrows });
            
            if (!durationInput || !durationArrows) {
                console.error('Duration input or arrows not found!');
                return;
            }
            
            // Add a visible background for debugging (remove this later)
            // durationArrows.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
            
            durationArrows.addEventListener('click', function(e) {
                console.log('Arrow clicked!', e);
                e.preventDefault();
                e.stopPropagation();
                
                // Get the bounding box of the arrow container
                const rect = durationArrows.getBoundingClientRect();
                const clickY = e.clientY - rect.top;
                const arrowHeight = rect.height;
                
                console.log('Click details:', { clickY, arrowHeight, rect });
                
                // The SVG has two triangular arrows - top half is up arrow, bottom half is down arrow
                const isUpArrow = clickY < (arrowHeight / 2);
                
                const currentValue = parseInt(durationInput.value) || 1000;
                const step = 100; // Increase/decrease by 100ms
                let newValue;
                
                if (isUpArrow) {
                    // Up arrow clicked - increase by 100ms
                    newValue = Math.min(currentValue + step, 10000);
                    console.log('Up arrow clicked: ' + currentValue + ' -> ' + newValue);
                } else {
                    // Down arrow clicked - decrease by 100ms  
                    newValue = Math.max(currentValue - step, 100);
                    console.log('Down arrow clicked: ' + currentValue + ' -> ' + newValue);
                }
                
                // Update the input value
                durationInput.value = newValue;
                
                // Update animation settings and trigger preview
                animationSettings.duration = newValue;
                updateAnimation();
            });
            
            // Add mousedown event as backup
            durationArrows.addEventListener('mousedown', function(e) {
                console.log('Arrow mousedown!', e);
            });
            
            // Add hover effect for better UX
            durationArrows.style.cursor = 'pointer';
            durationArrows.addEventListener('mouseenter', function() {
                console.log('Arrow hover enter');
                this.style.opacity = '0.8';
            });
            durationArrows.addEventListener('mouseleave', function() {
                console.log('Arrow hover leave');
                this.style.opacity = '1';
            });
        }

        function resizePluginToContent() {
            setTimeout(() => {
                // Force a reflow to ensure accurate measurements
                document.body.offsetHeight;
                
                // Get all the main sections
                const stepIndicator = document.querySelector('.step-indicator');
                const headerBorder = document.querySelector('.header-border');
                const footer = document.querySelector('.footer');
                
                // Get the currently visible section
                const chooseSection = document.getElementById('choose-section');
                const previewSection = document.getElementById('preview-section');
                const activeSection = chooseSection.style.display !== 'none' ? chooseSection : previewSection;
                
                // Calculate heights
                const stepIndicatorHeight = stepIndicator.getBoundingClientRect().height;
                const headerBorderHeight = headerBorder.getBoundingClientRect().height;
                const activeSectionHeight = activeSection.getBoundingClientRect().height;
                const footerHeight = footer.getBoundingClientRect().height;
                
                // Get computed styles for margins
                const stepIndicatorStyle = window.getComputedStyle(stepIndicator);
                const headerBorderStyle = window.getComputedStyle(headerBorder);
                const footerStyle = window.getComputedStyle(footer);
                
                const stepIndicatorMargin = parseInt(stepIndicatorStyle.marginBottom) || 0;
                const headerBorderMargin = parseInt(headerBorderStyle.marginBottom) || 0;
                const footerMargin = parseInt(footerStyle.marginTop) || 0;
                
                // Body padding (16px top + 16px bottom = 32px)
                const bodyPadding = 32;
                
                const totalHeight = stepIndicatorHeight + stepIndicatorMargin + 
                                headerBorderHeight + headerBorderMargin + 
                                activeSectionHeight + footerMargin + 
                                footerHeight + bodyPadding;
                
                // Add a small buffer to prevent cutting off
                const finalHeight = Math.ceil(totalHeight) + 5;
                
                
                // Send resize message to Figma
                parent.postMessage({ 
                    pluginMessage: { 
                        type: 'resize-window', 
                        data: { 
                            height: finalHeight,
                            animate: true,
                            // duration: 50
                        }
                    } 
                }, '*');
            }, 0);
        }


        // Initialize the plugin
        init();
    </script>
</body>
</html>